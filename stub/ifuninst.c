/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuninst.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7228:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7230;

g7229:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7232;

g7237:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7238:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7240;

g7239:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7242;

g7249:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto popiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7227;

g7226:
  if (_trace) printf("g7226:\n");
  arg1 = arg1 + t3;

g7225:
  if (_trace) printf("g7225:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7250:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7252;

g7251:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7254;

g7260:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7262:
  if (_trace) printf("g7262:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7261;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7261:
  if (_trace) printf("g7261:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7252:
  if (_trace) printf("g7252:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7251;

g7254:
  if (_trace) printf("g7254:\n");
  if ((t8 & 1) == 0)
    goto g7253;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7250;

g7253:
  if (_trace) printf("g7253:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7257:
#endif
#ifdef MINIMA

g7257:
  if (_trace) printf("g7257:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7256;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7259;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7250;

g7259:
  if (_trace) printf("g7259:\n");
  goto dbcachemisstrap;
#endif

g7256:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7240:
  if (_trace) printf("g7240:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7239;

g7242:
  if (_trace) printf("g7242:\n");
  if ((t9 & 1) == 0)
    goto g7241;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7238;

g7241:
  if (_trace) printf("g7241:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7246:
  if (_trace) printf("g7246:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7245;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7249;
#ifndef MINIMA

g7245:
#endif
#ifdef MINIMA

g7245:
  if (_trace) printf("g7245:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7244;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7248;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7238;

g7248:
  if (_trace) printf("g7248:\n");
  goto dbcachemisstrap;
#endif

g7244:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7230:
  if (_trace) printf("g7230:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7229;

g7232:
  if (_trace) printf("g7232:\n");
  if ((t9 & 1) == 0)
    goto g7231;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7228;

g7231:
  if (_trace) printf("g7231:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7234:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7227:
  if (_trace) printf("g7227:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7263:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7265;

g7264:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7267;

g7272:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7226;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7226;

g7265:
  if (_trace) printf("g7265:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7264;

g7267:
  if (_trace) printf("g7267:\n");
  if ((t9 & 1) == 0)
    goto g7266;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7263;

g7266:
  if (_trace) printf("g7266:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7269:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7276:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7278;

g7277:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7280;

g7285:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7286:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7288;

g7287:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7290;

g7297:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto movemiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7275;

g7274:
  if (_trace) printf("g7274:\n");
  arg1 = arg1 + t3;

g7273:
  if (_trace) printf("g7273:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7298:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7300;

g7299:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7302;

g7308:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7310:
  if (_trace) printf("g7310:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7309;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7309:
  if (_trace) printf("g7309:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7300:
  if (_trace) printf("g7300:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7299;

g7302:
  if (_trace) printf("g7302:\n");
  if ((t8 & 1) == 0)
    goto g7301;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7298;

g7301:
  if (_trace) printf("g7301:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7305:
#endif
#ifdef MINIMA

g7305:
  if (_trace) printf("g7305:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7304;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7307;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7298;

g7307:
  if (_trace) printf("g7307:\n");
  goto dbcachemisstrap;
#endif

g7304:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7288:
  if (_trace) printf("g7288:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7287;

g7290:
  if (_trace) printf("g7290:\n");
  if ((t9 & 1) == 0)
    goto g7289;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7286;

g7289:
  if (_trace) printf("g7289:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7294:
  if (_trace) printf("g7294:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7293;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7297;
#ifndef MINIMA

g7293:
#endif
#ifdef MINIMA

g7293:
  if (_trace) printf("g7293:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7292;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7296;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7286;

g7296:
  if (_trace) printf("g7296:\n");
  goto dbcachemisstrap;
#endif

g7292:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7278:
  if (_trace) printf("g7278:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7277;

g7280:
  if (_trace) printf("g7280:\n");
  if ((t9 & 1) == 0)
    goto g7279;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7276;

g7279:
  if (_trace) printf("g7279:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7282:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7275:
  if (_trace) printf("g7275:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7311:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7313;

g7312:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7315;

g7320:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7274;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7274;

g7313:
  if (_trace) printf("g7313:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7312;

g7315:
  if (_trace) printf("g7315:\n");
  if ((t9 & 1) == 0)
    goto g7314;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7311;

g7314:
  if (_trace) printf("g7314:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7317:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7324:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7326;

g7325:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7328;

g7333:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7334:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7336;

g7335:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7338;

g7345:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto pushadiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7323;

g7322:
  if (_trace) printf("g7322:\n");
  arg1 = arg1 + t3;

g7321:
  if (_trace) printf("g7321:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7336:
  if (_trace) printf("g7336:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7335;

g7338:
  if (_trace) printf("g7338:\n");
  if ((t9 & 1) == 0)
    goto g7337;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7334;

g7337:
  if (_trace) printf("g7337:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7342:
  if (_trace) printf("g7342:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7341;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7345;
#ifndef MINIMA

g7341:
#endif
#ifdef MINIMA

g7341:
  if (_trace) printf("g7341:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7340;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7344;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7334;

g7344:
  if (_trace) printf("g7344:\n");
  goto dbcachemisstrap;
#endif

g7340:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7326:
  if (_trace) printf("g7326:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7325;

g7328:
  if (_trace) printf("g7328:\n");
  if ((t9 & 1) == 0)
    goto g7327;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7324;

g7327:
  if (_trace) printf("g7327:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7330:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7323:
  if (_trace) printf("g7323:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7346:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7348;

g7347:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7350;

g7355:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7322;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7322;

g7348:
  if (_trace) printf("g7348:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7347;

g7350:
  if (_trace) printf("g7350:\n");
  if ((t9 & 1) == 0)
    goto g7349;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7346;

g7349:
  if (_trace) printf("g7349:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7352:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

g7356:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg1 - arg5;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7358;

g7357:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7360;

g7367:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t7 = t2 & 63;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

g7358:
  if (_trace) printf("g7358:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7357;

g7360:
  if (_trace) printf("g7360:\n");
  if ((t6 & 1) == 0)
    goto g7359;
  /* Do the indirect thing */
  arg1 = (u32)t1;
  goto g7356;

g7359:
  if (_trace) printf("g7359:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7364:
  if (_trace) printf("g7364:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7363;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7367;
#ifndef MINIMA

g7363:
#endif
#ifdef MINIMA

g7363:
  if (_trace) printf("g7363:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7362;
  t4 = arg1 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg1 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7366;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t1;
  goto g7356;

g7366:
  if (_trace) printf("g7366:\n");
  goto dbcachemisstrap;
#endif

g7362:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* Memory Read Internal */

g7368:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7370;

g7369:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7372;

g7378:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7380:
  if (_trace) printf("g7380:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7379;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7379:
  if (_trace) printf("g7379:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7370:
  if (_trace) printf("g7370:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7369;

g7372:
  if (_trace) printf("g7372:\n");
  if ((t8 & 1) == 0)
    goto g7371;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7368;

g7371:
  if (_trace) printf("g7371:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7375:
#endif
#ifdef MINIMA

g7375:
  if (_trace) printf("g7375:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7374;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7377;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7368;

g7377:
  if (_trace) printf("g7377:\n");
  goto dbcachemisstrap;
#endif

g7374:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  /* Memory Read Internal */

g7381:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7383;

g7382:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7385;

g7391:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7393:
  if (_trace) printf("g7393:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7392;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7392:
  if (_trace) printf("g7392:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7383:
  if (_trace) printf("g7383:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7382;

g7385:
  if (_trace) printf("g7385:\n");
  if ((t8 & 1) == 0)
    goto g7384;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7381;

g7384:
  if (_trace) printf("g7384:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7388:
#endif
#ifdef MINIMA

g7388:
  if (_trace) printf("g7388:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7387;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7390;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7381;

g7390:
  if (_trace) printf("g7390:\n");
  goto dbcachemisstrap;
#endif

g7387:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceref;
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7394:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7396;

g7395:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7398;

g7403:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7404:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7406;

g7405:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7408;

g7415:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

g7416:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg5 - t4;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7418;

g7417:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7420;

g7427:
  /* set CDR-NEXT */
  t2 = t2 & 63;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)iSP = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;

g7418:
  if (_trace) printf("g7418:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7417;

g7420:
  if (_trace) printf("g7420:\n");
  if ((t6 & 1) == 0)
    goto g7419;
  /* Do the indirect thing */
  arg5 = (u32)t1;
  goto g7416;

g7419:
  if (_trace) printf("g7419:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7424:
  if (_trace) printf("g7424:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7423;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7427;
#ifndef MINIMA

g7423:
#endif
#ifdef MINIMA

g7423:
  if (_trace) printf("g7423:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7422;
  t4 = arg5 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg5 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7426;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t1;
  goto g7416;

g7426:
  if (_trace) printf("g7426:\n");
  goto dbcachemisstrap;
#endif

g7422:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g7406:
  if (_trace) printf("g7406:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7405;

g7408:
  if (_trace) printf("g7408:\n");
  if ((t7 & 1) == 0)
    goto g7407;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7404;

g7407:
  if (_trace) printf("g7407:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7412:
  if (_trace) printf("g7412:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7411;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7415;
#ifndef MINIMA

g7411:
#endif
#ifdef MINIMA

g7411:
  if (_trace) printf("g7411:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7410;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7414;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7404;

g7414:
  if (_trace) printf("g7414:\n");
  goto dbcachemisstrap;
#endif

g7410:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7396:
  if (_trace) printf("g7396:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7395;

g7398:
  if (_trace) printf("g7398:\n");
  if ((t7 & 1) == 0)
    goto g7397;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7394;

g7397:
  if (_trace) printf("g7397:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7400:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceset;
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7428:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7430;

g7429:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7432;

g7437:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7438:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7440;

g7439:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7442;

g7449:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7450:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);
  t3 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg5 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t4 = *(s32 *)t4;
  t3 = (u8)(t3 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7452;

g7451:
  t7 = zero + 240;
  t8 = t8 >> (t3 & 63);
  t7 = t7 >> (t3 & 63);
  if (t8 & 1)
    goto g7454;

g7460:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);
  t7 = LDQ_U(t5);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* In range? */
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;
  t6 = (t3 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g7462:
  if (_trace) printf("g7462:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t4 = t1;
  /* J. if in cache */
  if (t8 != 0)
    goto g7461;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

g7461:
  if (_trace) printf("g7461:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* reconstruct SCA */
  t5 = (t6 * 8) + t5;
  /* Store in stack */
  *(u32 *)t5 = t1;
  /* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;

g7452:
  if (_trace) printf("g7452:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t4 = *(s32 *)t5;
  /* Read from stack cache */
  t3 = *(s32 *)(t5 + 4);
  goto g7451;

g7454:
  if (_trace) printf("g7454:\n");
  if ((t7 & 1) == 0)
    goto g7453;
  /* Do the indirect thing */
  arg5 = (u32)t4;
  goto g7450;

g7453:
  if (_trace) printf("g7453:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g7457:
#endif
#ifdef MINIMA

g7457:
  if (_trace) printf("g7457:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7456;
  t5 = arg5 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t4 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg5 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7459;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t4;
  goto g7450;

g7459:
  if (_trace) printf("g7459:\n");
  goto dbcachemisstrap;
#endif

g7456:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g7440:
  if (_trace) printf("g7440:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7439;

g7442:
  if (_trace) printf("g7442:\n");
  if ((t7 & 1) == 0)
    goto g7441;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7438;

g7441:
  if (_trace) printf("g7441:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7446:
  if (_trace) printf("g7446:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7445;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7449;
#ifndef MINIMA

g7445:
#endif
#ifdef MINIMA

g7445:
  if (_trace) printf("g7445:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7444;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7448;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7438;

g7448:
  if (_trace) printf("g7448:\n");
  goto dbcachemisstrap;
#endif

g7444:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7430:
  if (_trace) printf("g7430:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7429;

g7432:
  if (_trace) printf("g7432:\n");
  if ((t7 & 1) == 0)
    goto g7431;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7428;

g7431:
  if (_trace) printf("g7431:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7434:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceloc;
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7463:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7465;

g7464:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7467;

g7472:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7473:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7475;

g7474:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7477;

g7484:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

g7475:
  if (_trace) printf("g7475:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7474;

g7477:
  if (_trace) printf("g7477:\n");
  if ((t7 & 1) == 0)
    goto g7476;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7473;

g7476:
  if (_trace) printf("g7476:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7481:
  if (_trace) printf("g7481:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7480;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7484;
#ifndef MINIMA

g7480:
#endif
#ifdef MINIMA

g7480:
  if (_trace) printf("g7480:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7479;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7483;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7473;

g7483:
  if (_trace) printf("g7483:\n");
  goto dbcachemisstrap;
#endif

g7479:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7465:
  if (_trace) printf("g7465:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7464;

g7467:
  if (_trace) printf("g7467:\n");
  if ((t7 & 1) == 0)
    goto g7466;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7463;

g7466:
  if (_trace) printf("g7466:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7469:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
