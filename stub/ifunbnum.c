/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunbnum.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Bignums. */
/* start DoAddBignumStep */

  /* Halfword operand from stack instruction - DoAddBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

doaddbignumstep:
  if (_trace) printf("doaddbignumstep:\n");
#ifdef TRACING
#endif

DoAddBignumStepIM:
  if (_trace) printf("DoAddBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoaddbignumstep;
#ifdef TRACING
#endif

DoAddBignumStepSP:
  if (_trace) printf("DoAddBignumStepSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoaddbignumstep;
#endif

DoAddBignumStepLP:
  if (_trace) printf("DoAddBignumStepLP:\n");
#ifdef TRACING
  goto headdoaddbignumstep;
#endif

DoAddBignumStepFP:
  if (_trace) printf("DoAddBignumStepFP:\n");

headdoaddbignumstep:
  if (_trace) printf("headdoaddbignumstep:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoaddbignumstep:
  if (_trace) printf("begindoaddbignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get arg2 */
  arg2 = *(s32 *)iSP;
  /* and its tag */
  t2 = *(s32 *)(iSP + 4);
  t3 = arg1 >> 32;
  /* Strip type from arg3 */
  arg1 = (u32)arg1;
  t4 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto addbignumsteplose;
  /* Get arg1 */
  arg3 = *(s32 *)(iSP + -8);
  /* and its tag */
  t1 = *(s32 *)(iSP + -4);
  /* Clear sign extension from arg2 */
  arg2 = (u32)arg2;
  t4 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto addbignumsteplose;
  /* Clear sign extension */
  arg3 = (u32)arg3;
  t4 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto addbignumsteplose;
  arg4 = arg1 + arg2;
  arg5 = arg3 + arg4;
  /* Shift the carry into arg6 */
  arg6 = arg5 >> 32;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Store fixnum result */
  *(u32 *)(iSP + -8) = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + -4) = t1;
  /* Store the carry if any */
  *(u32 *)iSP = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

addbignumsteplose:
  if (_trace) printf("addbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoAddBignumStep */
  /* End of Halfword operand from stack instruction - DoAddBignumStep */
/* start DoSubBignumStep */

  /* Halfword operand from stack instruction - DoSubBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

dosubbignumstep:
  if (_trace) printf("dosubbignumstep:\n");
#ifdef TRACING
#endif

DoSubBignumStepIM:
  if (_trace) printf("DoSubBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindosubbignumstep;
#ifdef TRACING
#endif

DoSubBignumStepSP:
  if (_trace) printf("DoSubBignumStepSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdosubbignumstep;
#endif

DoSubBignumStepLP:
  if (_trace) printf("DoSubBignumStepLP:\n");
#ifdef TRACING
  goto headdosubbignumstep;
#endif

DoSubBignumStepFP:
  if (_trace) printf("DoSubBignumStepFP:\n");

headdosubbignumstep:
  if (_trace) printf("headdosubbignumstep:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindosubbignumstep:
  if (_trace) printf("begindosubbignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get arg2 */
  arg2 = *(s32 *)iSP;
  /* and its tag */
  t2 = *(s32 *)(iSP + 4);
  t3 = arg1 >> 32;
  /* Strip type from arg3 */
  arg1 = (u32)arg1;
  t4 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto subbignumsteplose;
  /* Get arg1 */
  arg3 = *(s32 *)(iSP + -8);
  /* and its tag */
  t1 = *(s32 *)(iSP + -4);
  /* Clear sign extension from arg2 */
  arg2 = (u32)arg2;
  t4 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto subbignumsteplose;
  /* Clear sign extension */
  arg3 = (u32)arg3;
  t4 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto subbignumsteplose;
  /* arg1-arg2 */
  arg4 = arg3 - arg2;
  /* arg6=1 if we borrowed in 1st step */
  arg6 = ((s64)arg4 < (s64)zero) ? 1 : 0;
  /* Truncate 1st step to 32-bits */
  arg4 = (u32)arg4;
  /* (arg1-arg2)-arg3 */
  arg5 = arg4 - arg1;
  /* t6=1 if we borrowed in 2nd step */
  t6 = ((s64)arg5 < (s64)zero) ? 1 : 0;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Store fixnum result */
  *(u32 *)(iSP + -8) = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + -4) = t1;
  /* Compute borrow */
  arg6 = arg6 + t6;
  /* Store the borrow if any */
  *(u32 *)iSP = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

subbignumsteplose:
  if (_trace) printf("subbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoSubBignumStep */
  /* End of Halfword operand from stack instruction - DoSubBignumStep */
/* start DoMultiplyBignumStep */

  /* Halfword operand from stack instruction - DoMultiplyBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

domultiplybignumstep:
  if (_trace) printf("domultiplybignumstep:\n");
#ifdef TRACING
#endif

DoMultiplyBignumStepIM:
  if (_trace) printf("DoMultiplyBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomultiplybignumstep;
#ifdef TRACING
#endif

DoMultiplyBignumStepSP:
  if (_trace) printf("DoMultiplyBignumStepSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplybignumstep;
#endif

DoMultiplyBignumStepLP:
  if (_trace) printf("DoMultiplyBignumStepLP:\n");
#ifdef TRACING
  goto headdomultiplybignumstep;
#endif

DoMultiplyBignumStepFP:
  if (_trace) printf("DoMultiplyBignumStepFP:\n");

headdomultiplybignumstep:
  if (_trace) printf("headdomultiplybignumstep:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindomultiplybignumstep:
  if (_trace) printf("begindomultiplybignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get arg1 */
  arg2 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t2 = arg1 >> 32;
  /* Strip type from arg2 */
  arg1 = (u32)arg1;
  t4 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto multbignumsteplose;
  arg2 = (u32)arg2;
  t4 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto multbignumsteplose;
  /* arg1*arg2 */
  arg3 = arg2 * arg1;
  /* arg6=high order word */
  arg6 = (u32)(arg3 >> ((4&7)*8));
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Store fixnum result ls word */
  *(u32 *)iSP = arg3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  /* Store ms word */
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto cachevalid;

multbignumsteplose:
  if (_trace) printf("multbignumsteplose:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyBignumStep */
  /* End of Halfword operand from stack instruction - DoMultiplyBignumStep */
/* start DoDivideBignumStep */

  /* Halfword operand from stack instruction - DoDivideBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

dodividebignumstep:
  if (_trace) printf("dodividebignumstep:\n");
#ifdef TRACING
#endif

DoDivideBignumStepIM:
  if (_trace) printf("DoDivideBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindodividebignumstep;
#ifdef TRACING
#endif

DoDivideBignumStepSP:
  if (_trace) printf("DoDivideBignumStepSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdodividebignumstep;
#endif

DoDivideBignumStepLP:
  if (_trace) printf("DoDivideBignumStepLP:\n");
#ifdef TRACING
  goto headdodividebignumstep;
#endif

DoDivideBignumStepFP:
  if (_trace) printf("DoDivideBignumStepFP:\n");

headdodividebignumstep:
  if (_trace) printf("headdodividebignumstep:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindodividebignumstep:
  if (_trace) printf("begindodividebignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get arg2 */
  arg2 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t4 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto divbignumsteplose1;
  /* J. if division by zero */
  if (arg1 == 0)
    goto divbignumsteplose2;
  arg2 = (u32)arg2;
  /* Get arg1 */
  arg3 = *(s32 *)(iSP + -8);
  t3 = *(s32 *)(iSP + -4);
  t4 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto divbignumsteplose1;
  /* arg2=(ash arg2 32) */
  arg2 = arg2 << 32;
  arg3 = (u32)arg3;
  t4 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto divbignumsteplose1;
  /* arg1+(ash arg2 32) */
  arg4 = arg3 | arg2;
  /* t1 is now the quotient */
  t1 = arg4 / arg1;
  t2 = t1 * arg1;
  /* t2 is now the remainder */
  t2 = arg4 - t2;
  /* store quotient (already fixnum) */
  *(u32 *)(iSP + -8) = t1;
  /* store remainder (already fixnum) */
  *(u32 *)iSP = t2;
  goto NEXTINSTRUCTION;

divbignumsteplose1:
  if (_trace) printf("divbignumsteplose1:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

divbignumsteplose2:
  if (_trace) printf("divbignumsteplose2:\n");
  arg5 = 0;
  arg2 = 2;
  goto illegaloperand;

/* end DoDivideBignumStep */
  /* End of Halfword operand from stack instruction - DoDivideBignumStep */
/* start DoLshcBignumStep */

  /* Halfword operand from stack instruction - DoLshcBignumStep */

dolshcbignumstep:
  if (_trace) printf("dolshcbignumstep:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoLshcBignumStepIM:
  if (_trace) printf("DoLshcBignumStepIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8733:
  if (_trace) printf("g8733:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindolshcbignumstep;
#ifdef TRACING
#endif

DoLshcBignumStepSP:
  if (_trace) printf("DoLshcBignumStepSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdolshcbignumstep;
#endif

DoLshcBignumStepLP:
  if (_trace) printf("DoLshcBignumStepLP:\n");
#ifdef TRACING
  goto headdolshcbignumstep;
#endif

DoLshcBignumStepFP:
  if (_trace) printf("DoLshcBignumStepFP:\n");

headdolshcbignumstep:
  if (_trace) printf("headdolshcbignumstep:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindolshcbignumstep:
  if (_trace) printf("begindolshcbignumstep:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* Get arg2 */
  arg2 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack */
  iSP = iSP - 8;
  t3 = arg1 >> 32;
  /* Strip type from arg3 */
  arg1 = (u32)arg1;
  t4 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto lshcbignumsteplose;
  arg2 = (u32)arg2;
  /* Get arg1 */
  arg3 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t4 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto lshcbignumsteplose;
  /* arg2=(ash arg2 32) */
  arg2 = arg2 << 32;
  arg3 = (u32)arg3;
  t4 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto lshcbignumsteplose;
  /* arg1+(ash arg2 32) */
  arg4 = arg3 | arg2;
  arg5 = arg4 << (arg1 & 63);
  /* Extract the result */
  arg6 = (s64)arg5 >> 32;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Store the result as a fixnum */
  *(u32 *)iSP = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

lshcbignumsteplose:
  if (_trace) printf("lshcbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoLshcBignumStep */
  /* End of Halfword operand from stack instruction - DoLshcBignumStep */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbnum.as */
