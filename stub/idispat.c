/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/idispat.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* This file implements the main instruction dispatch loop. */
/* start DummyDoNothingSubroutine */


dummydonothingsubroutine:
  if (_trace) printf("dummydonothingsubroutine:\n");
  goto continuecurrentinstruction;

/* end DummyDoNothingSubroutine */
/* start MemoryReadData */


memoryreaddata:
  if (_trace) printf("memoryreaddata:\n");
  /* Memory Read Internal */

g6043:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6045;

g6044:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6047;

g6053:
  goto *((u64* )r0); /* ret */

memoryreaddatadecode:
  if (_trace) printf("memoryreaddatadecode:\n");
  if (t6 == 0)
    goto g6046;

g6045:
  if (_trace) printf("g6045:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6044;

g6047:
  if (_trace) printf("g6047:\n");
  if ((t7 & 1) == 0)
    goto g6046;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6043;

g6046:
  if (_trace) printf("g6046:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g6050:
  if (_trace) printf("g6050:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g6049;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g6053;
#ifndef MINIMA

g6049:
#endif
#ifdef MINIMA

g6049:
  if (_trace) printf("g6049:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g6048;
  t5 = arg2 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  arg6 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg2 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g6052;
  /* Extract the pointer, and indirect */
  arg2 = (u32)arg6;
  goto g6043;

g6052:
  if (_trace) printf("g6052:\n");
  goto dbcachemisstrap;
#endif

g6048:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

/* end MemoryReadData */
/* start MemoryReadGeneral */


memoryreadgeneral:
  if (_trace) printf("memoryreadgeneral:\n");
  /* Memory Read Internal */

g6054:
  t7 = arg2 + ivory;
  /* Cycle-number -> table offset */
  t8 = (arg3 * 4);
  arg5 = LDQ_U(t7);
  t8 = (t8 * 4) + ivory;
  arg6 = (t7 * 4);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6056;

g6055:
  t8 = t8 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6058;

g6064:
  goto *((u64* )r0); /* ret */

memoryreadgeneraldecode:
  if (_trace) printf("memoryreadgeneraldecode:\n");
  if (t6 == 0)
    goto g6057;

g6056:
  if (_trace) printf("g6056:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6055;

g6058:
  if (_trace) printf("g6058:\n");

g6057:
  if (_trace) printf("g6057:\n");
  /* Cycle-number -> table offset */
  t8 = (arg3 * 4);
  t8 = (t8 * 4) + ivory;
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g6062:
  if (_trace) printf("g6062:\n");
  t6 = t8 & MemoryActionIndirect;
  if (t6 == 0)
    goto g6061;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6054;

g6061:
  if (_trace) printf("g6061:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g6060;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g6064;
#ifndef MINIMA

g6060:
#endif
#ifdef MINIMA

g6060:
  if (_trace) printf("g6060:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g6059;
  t5 = arg2 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  arg6 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg2 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g6063;
  /* Extract the pointer, and indirect */
  arg2 = (u32)arg6;
  goto g6054;

g6063:
  if (_trace) printf("g6063:\n");
  goto dbcachemisstrap;
#endif

g6059:
  /* Perform memory action */
  arg1 = t8;
  arg2 = arg3;
  goto performmemoryaction;

/* end MemoryReadGeneral */
/* start MemoryReadHeader */


memoryreadheader:
  if (_trace) printf("memoryreadheader:\n");
  /* Memory Read Internal */

g6065:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6067;

g6066:
  t7 = zero + 64;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6069;

g6073:
  goto *((u64* )r0); /* ret */

memoryreadheaderdecode:
  if (_trace) printf("memoryreadheaderdecode:\n");
  if (t6 == 0)
    goto g6068;

g6067:
  if (_trace) printf("g6067:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6066;

g6069:
  if (_trace) printf("g6069:\n");
  if ((t7 & 1) == 0)
    goto g6068;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6065;

g6068:
  if (_trace) printf("g6068:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g6070:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end MemoryReadHeader */
/* start MemoryReadCdr */


memoryreadcdr:
  if (_trace) printf("memoryreadcdr:\n");
  /* Memory Read Internal */

g6074:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->cdr_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6076;

g6075:
  t7 = zero + 192;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6078;

g6082:
  goto *((u64* )r0); /* ret */

memoryreadcdrdecode:
  if (_trace) printf("memoryreadcdrdecode:\n");
  if (t6 == 0)
    goto g6077;

g6076:
  if (_trace) printf("g6076:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6075;

g6078:
  if (_trace) printf("g6078:\n");
  if ((t7 & 1) == 0)
    goto g6077;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6074;

g6077:
  if (_trace) printf("g6077:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->cdr);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g6079:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 9;
  goto performmemoryaction;

/* end MemoryReadCdr */
/* start DoICacheFill */


doicachefill:
  if (_trace) printf("doicachefill:\n");

ICACHEMISS:
  if (_trace) printf("ICACHEMISS:\n");
  /* Here when instruction cache miss detected.  Fill the cache from */
  /* PC and then resume interpreter loop */
  /* First round the PC down to an even halfword address */
  /* get the base of the icache */
  arg2 = *(u64 *)&(processor->icachebase);
  /* the even PC */
  epc = iPC & ~1L;
  ecp = epc >> (CacheLine_RShift & 63);
  arg1 = zero + -1;
  arg1 = arg1 + ((4) << 16);
  ecp = ecp << (CacheLine_LShift & 63);
  /* instn is instruction address here */
  instn = iPC >> 1;
  ecp = epc + ecp;
  ecp = ecp & arg1;
  /* temp=cpos*32 */
  arg3 = ecp << 5;
  /* cpos=cpos*16 */
  ecp = ecp << 4;
  /* temp2=base+cpos*32 */
  arg4 = arg2 + arg3;
  /* cpos=base+cpos*48 */
  ecp = arg4 + ecp;
  /* the odd PC */
  opc = epc | 1;
  /* Assume iPC is the even PC */
  iCP = ecp;
  /* See if iPC is the odd PC */
  arg1 = (iPC == opc) ? 1 : 0;
  ocp = ecp + CACHELINE_SIZE;
  /* Stash the odd cache pointer if iPC is the odd PC */
  if (arg1)
    iCP = ocp;
  hwdispatch = *(u64 *)&(processor->halfworddispatch);
  hwopmask = zero + 1023;
  fwdispatch = *(u64 *)&(processor->fullworddispatch);
  count = zero + 20;
  t11 = instn + ivory;
  iword = (t11 * 4);
  arg4 = LDQ_U(t11);
  iword = *(s32 *)iword;
  arg4 = (u8)(arg4 >> ((t11&7)*8));
  goto fillicacheprefetched;

pcbackone:
  if (_trace) printf("pcbackone:\n");
  /* Wire in continuation for even half */
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = epc;
  /* Backup in cache too */
  t10 = ecp - CACHELINE_SIZE;
  *(u64 *)&((CACHELINEP)ocp)->nextcp = ecp;
  /* Backup PC one halfword */
  arg1 = epc - 1;
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;
  /* TagType. */
  /* arg4=tag-cdr code */
  arg4 = arg4 & 63;
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;
  /* Wire in continuation for odd half */
  goto maybeunpack;

pcadvone:
  if (_trace) printf("pcadvone:\n");
  /* Simple advance of PC one halfword. */
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = opc;
  arg1 = opc + 1;
  *(u64 *)&((CACHELINEP)ecp)->nextcp = ocp;
  t10 = ocp + CACHELINE_SIZE;
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;
  /* TagType. */
  /* arg4=tag-cdr code */
  arg4 = arg4 & 63;
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;
  goto maybeunpack;
  /* This is the cache fill loop. */

fillicache:
  if (_trace) printf("fillicache:\n");
  t11 = instn + ivory;
  iword = (t11 * 4);
  arg4 = LDQ_U(t11);
  iword = *(s32 *)iword;
  arg4 = (u8)(arg4 >> ((t11&7)*8));

fillicacheprefetched:
  if (_trace) printf("fillicacheprefetched:\n");
#ifdef CACHEMETERING
  /* Increment the fill count for both cache entries */
  t10 = *(s32 *)&((CACHELINEP)ecp)->annotation;
  t11 = *(s32 *)&((CACHELINEP)ocp)->annotation;
  t10 = (u32)t10;
  t11 = (u32)t11;
  t10 = t10 + 1;
  *(u32 *)&((CACHELINEP)ecp)->annotation = t10;
  t11 = t11 + 1;
  *(u32 *)&((CACHELINEP)ocp)->annotation = t11;
#endif
  /* Set address of even cache posn. */
  *(u64 *)&((CACHELINEP)ecp)->pcdata = epc;
  /* CDR code << 6 */
  arg1 = arg4 & 192;
  /* TagType. */
  /* Strip cdr */
  arg4 = arg4 & 63;
  /* Set address of odd cache posn. */
  *(u64 *)&((CACHELINEP)ocp)->pcdata = opc;
  /* Strip nasty bits out. */
  iword = (u32)iword;

g6083:
  if (_trace) printf("g6083:\n");
  /* ready to remerge */
  arg2 = arg4 << 32;
  /* Zerotag means advance one HW */
  if (arg1 == 0)
    goto pcadvone;
  /* 2<<6 */
  arg1 = arg1 - 128;
  /* Tag=2 means backup one HW */
  if (arg1 == 0)
    goto pcbackone;
  /* Tag=1 means end of compiled function */
  if ((s64)arg1 < 0)
    goto pcendcf;

pcadvtwo:
  if (_trace) printf("pcadvtwo:\n");
  /* Tag=3 means advance over one full word */
  /* Wire in continuation for even half */
  /* Next word */
  arg1 = epc + 2;
  r31 = r31 | r31;
  /* corresponding CP entry */
  t10 = ecp + TWOCACHELINESIZE;
  /* Next PC even of next word */
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;
  /* Skip one fullword */
  arg1 = epc + 4;
  /* Next CP */
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;
  /* Wire in continuation for odd half */
  /* corresponding CP entry */
  t10 = ecp + FOURCACHELINESIZE;
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;
  /* TagType. */
  /* arg4=tag-cdr code */
  arg4 = arg4 & 63;
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;
  goto maybeunpack;

decodepackedword:
  if (_trace) printf("decodepackedword:\n");
  /* Here to decode a packed word */
#ifdef CACHEMETERING
  arg1 = *(s32 *)&processor->metervalue;
  /* The number of remaining tokens. */
  arg4 = *(s32 *)&processor->metercount;
  /* The cache miss meter buffer. */
  t10 = *(u64 *)&(processor->meterdatabuff);
  /* count the miss. */
  arg1 = arg1 + 1;
  /* Position for new data. */
  t11 = *(s32 *)&processor->meterpos;
  *(u32 *)&processor->metervalue = arg1;
  if (arg4 != 0)
    goto g6084;
  arg2 = *(s32 *)&processor->metermask;
  /* position of the current data item */
  t10 = (t11 * 4) + t10;
  t11 = t11 + 1;
  t11 = t11 & arg2;
  arg2 = *(s32 *)&processor->metermax;
  t12 = arg1 - arg2;
  if ((s64)t12 > 0)
    arg2 = arg1;
  *(u32 *)&processor->metermax = arg2;
  /* store the datapoint */
  *(u32 *)t10 = arg1;
  /* Position for new data. */
  *(u32 *)&processor->meterpos = t11;
  *(u32 *)&processor->metervalue = zero;
  arg4 = *(s32 *)&processor->meterfreq;

g6084:
  if (_trace) printf("g6084:\n");
  *(u32 *)&processor->metercount = arg4;
#endif
  /* arg4 contains the odd packedword */
  arg4 = iword >> 18;
  /* even opcode+2bits */
  t10 = iword >> 8;
  /* Save the odd instruction */
  *(u64 *)&((CACHELINEP)ocp)->instruction = arg4;
  /* First phase of even operand sign extension. */
  t11 = iword << 54;
  /* even operand+2bits */
  t12 = iword & hwopmask;
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ocp)->annotation = zero;
#endif
  /* even opcode */
  t10 = t10 & hwopmask;
  /* Second phase of even operand sign extension. */
  t11 = (s64)t11 >> 38;
  arg2 = t10 - 92;
  t10 = (t10 * 8) + hwdispatch;
  /* Merge signed/unsigned even operand */
  t12 = t11 | t12;
  arg2 = arg2 & ~3L;
  *(u32 *)&((CACHELINEP)ecp)->operand = t12;
  /* clear count if finish-call seen */
  if (arg2 == 0)
    count = arg2;
  /* odd opcode+2bits */
  arg2 = arg4 >> 8;
  /* First phase of odd operand sign extension. */
  t11 = arg4 << 54;
  /* odd operand+2bits */
  arg1 = arg4 & hwopmask;
  t10 = *(u64 *)t10;
  /* odd opcode */
  arg2 = arg2 & hwopmask;
  /* Second phase of odd operand sign extension. */
  t11 = (s64)t11 >> 38;
  *(u64 *)&((CACHELINEP)ecp)->code = t10;
  t12 = arg2 - 92;
  arg2 = (arg2 * 8) + hwdispatch;
  /* Merge signed/unsigned odd operand */
  arg1 = t11 | arg1;
  *(u32 *)&((CACHELINEP)ocp)->operand = arg1;
  t12 = t12 & ~3L;
  arg2 = *(u64 *)arg2;
  /* clear count if finish-call seen */
  if (t12 == 0)
    count = t12;
  *(u64 *)&((CACHELINEP)ocp)->code = arg2;
  goto enddecode;

maybeunpack:
  if (_trace) printf("maybeunpack:\n");
  /* reassemble tag and word. */
  iword = arg2 | iword;
  /* save the even instruction */
  *(u64 *)&((CACHELINEP)ecp)->instruction = iword;
  /* t10>=0 if packed */
  t10 = arg4 - 48;
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ecp)->annotation = zero;
#endif
#ifdef CACHEMETERING
  epc = *(s32 *)&processor->metervalue;
  /* The number of remaining tokens. */
  t12 = *(s32 *)&processor->metercount;
  /* The cache miss meter buffer. */
  t11 = *(u64 *)&(processor->meterdatabuff);
  /* count the miss. */
  epc = epc + 1;
  /* Position for new data. */
  arg1 = *(s32 *)&processor->meterpos;
  *(u32 *)&processor->metervalue = epc;
  if (t12 != 0)
    goto g6085;
  arg2 = *(s32 *)&processor->metermask;
  /* position of the current data item */
  t11 = (arg1 * 4) + t11;
  arg1 = arg1 + 1;
  arg1 = arg1 & arg2;
  arg2 = *(s32 *)&processor->metermax;
  t10 = epc - arg2;
  if ((s64)t10 > 0)
    arg2 = epc;
  *(u32 *)&processor->metermax = arg2;
  /* store the datapoint */
  *(u32 *)t11 = epc;
  /* Position for new data. */
  *(u32 *)&processor->meterpos = arg1;
  *(u32 *)&processor->metervalue = zero;
  t12 = *(s32 *)&processor->meterfreq;

g6085:
  if (_trace) printf("g6085:\n");
  *(u32 *)&processor->metercount = t12;
#endif
  /* B. if a packed instruction */
  if ((s64)t10 >= 0)
    goto decodepackedword;
  /* t11 is the fwdispatch index */
  t11 = (arg4 * 8) + fwdispatch;
  t12 = *(u64 *)&(processor->i_stage_error_hook);
  arg1 = arg4 - 33;
  /* Extract the opcode handler */
  t11 = *(u64 *)t11;
  /* Store I-STATE-ERROR at odd pc */
  *(u64 *)&((CACHELINEP)ocp)->code = t12;
  /* clear count if native instn seen */
  if (arg1 == 0)
    count = arg1;
  *(u64 *)&((CACHELINEP)ecp)->code = t11;

enddecode:
  if (_trace) printf("enddecode:\n");
  /* Here we decide if to stop filling the cache and return to the */
  /* instruction interpretation stream, or whether to fill further */
  instn = instn + 1;
  /* If count is zero, resume */
  if ((s64)count <= 0)
    goto cachevalid;
  epc = instn << 1;
  /* decrement count */
  count = count - 1;
  opc = epc | 1;
  /* pointer to the end of icache */
  t10 = *(u64 *)&(processor->endicache);
  ocp = ocp + TWOCACHELINESIZE;
  ecp = ecp + TWOCACHELINESIZE;
  t10 = ocp - t10;
  /* Still room for more */
  if ((s64)t10 <= 0)
    goto fillicache;
  goto cachevalid;

pcendcf:
  if (_trace) printf("pcendcf:\n");
  t11 = *(u64 *)&(processor->i_stage_error_hook);
  /* We reached the end of the fcn. */
  count = r31 | r31;
  /* Store I-STATE-ERROR dispatch at even and odd pc */
  *(u64 *)&((CACHELINEP)ecp)->code = t11;
  *(u64 *)&((CACHELINEP)ocp)->code = t11;
  goto enddecode;

/* end DoICacheFill */
  /* These are the instruction reentry points.  Instructions end by returning */
  /* control to one of these tags.  Most normal instructions reenter by jumping */
  /* to NEXTINSTRUCTION, which advances the PC and continues normally.   */
  /* Instructions that change the PC usually go directly to INTERPRETINSTRUCTION. */
  /* Instructions that fail/trap/exception etc, go to one of the other places. */
/* start iInterpret */


iinterpret:
  if (_trace) printf("iinterpret:\n");
  *(u64 *)&processor->asrr9 = r9;
  *(u64 *)&processor->asrr10 = r10;
  *(u64 *)&processor->asrr11 = r11;
  *(u64 *)&processor->asrr12 = r12;
  *(u64 *)&processor->asrr13 = r13;
  *(u64 *)&processor->asrr15 = r15;
  *(u64 *)&processor->asrr26 = r26;
  *(u64 *)&processor->asrr27 = r27;
  *(u64 *)&processor->asrr29 = r29;
  *(u64 *)&processor->asrr30 = r30;
  *(u64 *)&processor->asrr14 = r14;
  /* Setup our processor object handle */
  ivory = arg1;
  /* Upon entry, load cached state. */
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* First time in iCP will be zero. */
  if (iCP != 0)
    goto INTERPRETINSTRUCTION;
  goto ICACHEMISS;

interpretinstructionpredicted:
  if (_trace) printf("interpretinstructionpredicted:\n");
  /* Get the PC to check cache hit. */
  t2 = *(u64 *)&(((CACHELINEP)arg2)->pcdata);
  /* Assume FP mode */
  arg1 = iFP;
  /* Have we been asked to stop? */
  r0 = *(u64 *)&(processor->stop_interpreter);
  /* SP-pop mode constant */
  arg4 = iSP + -8;
  /* Grab the instruction/operand while stalled */
  arg3 = *(u64 *)&(((CACHELINEP)arg2)->instruction);
  t1 = iPC - t2;
  if (t1 != 0)
    goto interpretinstructionforbranch;
  iCP = arg2;
  /* Stop the world! someone wants out. */
  if (r0 != 0)
    goto traporsuspendmachine;
  goto continuecurrentinstruction;

interpretinstructionforjump:
  if (_trace) printf("interpretinstructionforjump:\n");

interpretinstructionforbranch:
  if (_trace) printf("interpretinstructionforbranch:\n");
  /* get the base of the icache */
  t5 = *(u64 *)&(processor->icachebase);
  t4 = zero + -1;
  t4 = t4 + ((4) << 16);
  arg2 = iPC >> 10;
  t3 = zero + -64;
  arg2 = arg2 & t3;
  arg2 = iPC + arg2;
  arg2 = arg2 & t4;
  /* temp=cpos*32 */
  t4 = arg2 << 5;
  /* cpos=cpos*16 */
  arg2 = arg2 << 4;
  /* temp2=base+cpos*32 */
  t5 = t5 + t4;

g6086:
  if (_trace) printf("g6086:\n");
  /* cpos=base+cpos*48 */
  arg2 = t5 + arg2;
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)iCP)->annotation = arg2;
#endif
  iCP = arg2;

INTERPRETINSTRUCTION:
  if (_trace) printf("INTERPRETINSTRUCTION:\n");
  r30 = *(u64 *)&(processor->asrr30);
  /* Have we been asked to stop? */
  r0 = *(u64 *)&(processor->stop_interpreter);
  /* Assume FP mode */
  arg1 = iFP;
  /* Grab the instruction/operand while stalled */
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  /* SP-pop mode constant */
  arg4 = iSP + -8;
  /* Get the PC to check cache hit. */
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);
  /* Stop the world! someone wants out. */
  if (r0 != 0)
    goto traporsuspendmachine;
  goto continuecurrentinstruction;

/* end iInterpret */



/* End of file automatically generated from ../alpha-emulator/idispat.as */
