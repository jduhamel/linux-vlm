/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunfext.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Field extraction instruction. */
/* start DoCharLdb */

  /* Field Extraction instruction - DoCharLdb */

docharldb:
  if (_trace) printf("docharldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCharLdbIM:
  if (_trace) printf("DoCharLdbIM:\n");

DoCharLdbSP:
  if (_trace) printf("DoCharLdbSP:\n");

DoCharLdbLP:
  if (_trace) printf("DoCharLdbLP:\n");

DoCharLdbFP:
  if (_trace) printf("DoCharLdbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* t7= -1 */
  t7 = zero - 1;
  /* get ARG1 tag/data */
  arg3 = *(s32 *)(iSP + 4);
  arg4 = *(s32 *)iSP;
  /* Size of field */
  arg1 = arg1 + 1;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Character;
  /* Clear sign extension now */
  arg4 = (u32)arg4;
  /* Not a character */
  if (t9 != 0)
    goto charldbexc;
  /* T4= shifted value if PP==0 */
  t4 = arg4 << (arg2 & 63);
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* T5= shifted value if PP<>0 */
  t5 = t4 >> 32;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T5= shifted value */
  if (arg2 == 0)
    t5 = t4;
  /* T3= masked value. */
  t3 = t5 & ~t7;
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

charldbexc:
  if (_trace) printf("charldbexc:\n");
  arg5 = 0;
  arg2 = 28;
  goto illegaloperand;

/* end DoCharLdb */
  /* End of Halfword operand from stack instruction - DoCharLdb */
/* start DoPLdb */

  /* Field Extraction instruction - DoPLdb */

dopldb:
  if (_trace) printf("dopldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPLdbIM:
  if (_trace) printf("DoPLdbIM:\n");

DoPLdbSP:
  if (_trace) printf("DoPLdbSP:\n");

DoPLdbLP:
  if (_trace) printf("DoPLdbLP:\n");

DoPLdbFP:
  if (_trace) printf("DoPLdbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* get arg1 tag/data */
  t2 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t2 = (u32)t2;
  t3 = t1 - Type_PhysicalAddress;
  t3 = t3 & 63;
  if (t3 == 0)
    goto pldbillop;
  /* Memory Read Internal */

g8198:
  /* Base of stack cache */
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;
  arg4 = (t5 * 4);
  arg3 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = t2 - t3;
  /* In range? */
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;
  arg4 = *(s32 *)arg4;
  arg3 = (u8)(arg3 >> ((t5&7)*8));
  if (t4 != 0)
    goto g8200;

g8199:
  arg4 = (u32)arg4;

g8206:
  /* t7= -1 */
  t7 = zero - 1;
  /* Size of field */
  arg1 = arg1 + 1;
  /* T4= shifted value if PP==0 */
  t4 = arg4 << (arg2 & 63);
  /* T5= shifted value if PP<>0 */
  t5 = t4 >> 32;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* T5= shifted value */
  if (arg2 == 0)
    t5 = t4;
  /* T3= masked value. */
  t3 = t5 & ~t7;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

pldbillop:
  if (_trace) printf("pldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = iSP - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

g8200:
  if (_trace) printf("g8200:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  arg4 = *(s32 *)t3;
  /* Read from stack cache */
  arg3 = *(s32 *)(t3 + 4);
  goto g8199;

/* end DoPLdb */
  /* End of Halfword operand from stack instruction - DoPLdb */
/* start DoPTagLdb */

  /* Field Extraction instruction - DoPTagLdb */

doptagldb:
  if (_trace) printf("doptagldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPTagLdbIM:
  if (_trace) printf("DoPTagLdbIM:\n");

DoPTagLdbSP:
  if (_trace) printf("DoPTagLdbSP:\n");

DoPTagLdbLP:
  if (_trace) printf("DoPTagLdbLP:\n");

DoPTagLdbFP:
  if (_trace) printf("DoPTagLdbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* get arg1 tag/data */
  t2 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t2 = (u32)t2;
  t3 = t1 - Type_PhysicalAddress;
  t3 = t3 & 63;
  if (t3 == 0)
    goto ptagldbillop;
  /* Memory Read Internal */

g8207:
  /* Base of stack cache */
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;
  arg4 = (t5 * 4);
  arg3 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = t2 - t3;
  /* In range? */
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;
  arg4 = *(s32 *)arg4;
  arg3 = (u8)(arg3 >> ((t5&7)*8));
  if (t4 != 0)
    goto g8209;

g8208:

g8215:
  /* t7= -1 */
  t7 = zero - 1;
  /* Size of field */
  arg1 = arg1 + 1;
  /* T4= shifted value if PP==0 */
  t4 = arg3 << (arg2 & 63);
  /* T5= shifted value if PP<>0 */
  t5 = t4 >> 32;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* T5= shifted value */
  if (arg2 == 0)
    t5 = t4;
  /* T3= masked value. */
  t3 = t5 & ~t7;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

ptagldbillop:
  if (_trace) printf("ptagldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = iSP - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

g8209:
  if (_trace) printf("g8209:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  arg4 = *(s32 *)t3;
  /* Read from stack cache */
  arg3 = *(s32 *)(t3 + 4);
  goto g8208;

/* end DoPTagLdb */
  /* End of Halfword operand from stack instruction - DoPTagLdb */
/* start DoDpb */

  /* Field Extraction instruction - DoDpb */

dodpb:
  if (_trace) printf("dodpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoDpbIM:
  if (_trace) printf("DoDpbIM:\n");

DoDpbSP:
  if (_trace) printf("DoDpbSP:\n");

DoDpbLP:
  if (_trace) printf("DoDpbLP:\n");

DoDpbFP:
  if (_trace) printf("DoDpbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* Get arg2 tag/data */
  t6 = *(s32 *)iSP;
  /* Get arg2 tag/data */
  t5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t6 = (u32)t6;
  /* get arg1 tag/data */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  /* Strip off any CDR code bits. */
  t1 = t5 & 63;
  /* Strip off any CDR code bits. */
  arg6 = arg3 & 63;
  t2 = (t1 == Type_Fixnum) ? 1 : 0;

g8228:
  if (_trace) printf("g8228:\n");
  if (t2 == 0)
    goto g8221;
  /* Here if argument TypeFixnum */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;

g8225:
  if (_trace) printf("g8225:\n");
  if (arg5 == 0)
    goto g8218;
  /* Here if argument TypeFixnum */
  /* t7= -2 */
  t7 = zero - 2;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* reuse t5 as mask */
  t5 = ~t7;
  /* T3= masked new value. */
  t3 = arg4 & ~t7;
  /* t5 is the inplace mask */
  t5 = t5 << (arg2 & 63);
  /* t4 is the shifted field */
  t4 = t3 << (arg2 & 63);
  /* Clear out existing bits in arg2 field */
  t6 = t6 & ~t5;
  /* Put the new bits in */
  t6 = t4 | t6;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  *(u32 *)iSP = t6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

g8222:
  if (_trace) printf("g8222:\n");

g8221:
  if (_trace) printf("g8221:\n");
  /* Here for all other cases */

g8217:
  if (_trace) printf("g8217:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t5;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto numericexception;
  goto g8219;

g8218:
  if (_trace) printf("g8218:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto numericexception;

g8219:
  if (_trace) printf("g8219:\n");

g8220:
  if (_trace) printf("g8220:\n");

/* end DoDpb */
  /* End of Halfword operand from stack instruction - DoDpb */
/* start DoCharDpb */

  /* Field Extraction instruction - DoCharDpb */

dochardpb:
  if (_trace) printf("dochardpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCharDpbIM:
  if (_trace) printf("DoCharDpbIM:\n");

DoCharDpbSP:
  if (_trace) printf("DoCharDpbSP:\n");

DoCharDpbLP:
  if (_trace) printf("DoCharDpbLP:\n");

DoCharDpbFP:
  if (_trace) printf("DoCharDpbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* Get arg2 tag/data */
  t6 = *(s32 *)iSP;
  /* Get arg2 tag/data */
  t5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t6 = (u32)t6;
  /* get arg1 tag/data */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  /* Strip off any CDR code bits. */
  t1 = t5 & 63;
  /* Strip off any CDR code bits. */
  arg6 = arg3 & 63;
  t2 = (t1 == Type_Character) ? 1 : 0;

g8241:
  if (_trace) printf("g8241:\n");
  if (t2 == 0)
    goto g8234;
  /* Here if argument TypeCharacter */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;

g8238:
  if (_trace) printf("g8238:\n");
  if (arg5 == 0)
    goto g8231;
  /* Here if argument TypeFixnum */
  /* t7= -2 */
  t7 = zero - 2;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* reuse t5 as mask */
  t5 = ~t7;
  /* T3= masked new value. */
  t3 = arg4 & ~t7;
  /* t5 is the inplace mask */
  t5 = t5 << (arg2 & 63);
  /* t4 is the shifted field */
  t4 = t3 << (arg2 & 63);
  /* Clear out existing bits in arg2 field */
  t6 = t6 & ~t5;
  /* Put the new bits in */
  t6 = t4 | t6;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Character;
  *(u32 *)iSP = t6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

g8235:
  if (_trace) printf("g8235:\n");

g8234:
  if (_trace) printf("g8234:\n");
  /* Here for all other cases */

g8230:
  if (_trace) printf("g8230:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t5;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 27;
  goto spareexception;
  goto g8232;

g8231:
  if (_trace) printf("g8231:\n");
  arg5 = 0;
  arg2 = 27;
  goto illegaloperand;

g8232:
  if (_trace) printf("g8232:\n");

g8233:
  if (_trace) printf("g8233:\n");

/* end DoCharDpb */
  /* End of Halfword operand from stack instruction - DoCharDpb */
/* start DoPDpb */

  /* Field Extraction instruction - DoPDpb */

dopdpb:
  if (_trace) printf("dopdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPDpbIM:
  if (_trace) printf("DoPDpbIM:\n");

DoPDpbSP:
  if (_trace) printf("DoPDpbSP:\n");

DoPDpbLP:
  if (_trace) printf("DoPDpbLP:\n");

DoPDpbFP:
  if (_trace) printf("DoPDpbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* Get arg2 tag/data */
  t2 = *(s32 *)iSP;
  /* Get arg2 tag/data */
  t1 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = (u32)t2;
  t3 = t1 - Type_PhysicalAddress;
  t3 = t3 & 63;
  if (t3 == 0)
    goto pdpbillop;
  /* get arg1 tag/data */
  arg4 = *(s32 *)iSP;
  /* get arg1 tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* Memory Read Internal */

g8242:
  /* Base of stack cache */
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;
  t6 = (t1 * 4);
  t8 = LDQ_U(t1);
  /* Stack cache offset */
  t3 = t2 - t3;
  /* In range? */
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;
  t6 = *(s32 *)t6;
  t8 = (u8)(t8 >> ((t1&7)*8));
  if (t4 != 0)
    goto g8244;

g8243:
  t6 = (u32)t6;

g8250:
  t6 = (u32)t6;
  /* Strip off any CDR code bits. */
  t1 = arg3 & 63;
  t10 = (t1 == Type_Fixnum) ? 1 : 0;

g8257:
  if (_trace) printf("g8257:\n");
  if (t10 == 0)
    goto g8252;
  /* Here if argument TypeFixnum */
  /* t7= -2 */
  t7 = zero - 2;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* reuse t5 as mask */
  t5 = ~t7;
  /* T3= masked new value. */
  t3 = arg4 & ~t7;
  /* t5 is the inplace mask */
  t5 = t5 << (arg2 & 63);
  /* t4 is the shifted field */
  t4 = t3 << (arg2 & 63);
  /* Clear out existing bits in arg2 field */
  t6 = t6 & ~t5;
  /* Put the new bits in */
  t6 = t4 | t6;
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;
  t5 = (t3 * 4);
  t1 = LDQ_U(t3);
  /* Stack cache offset */
  t4 = t2 - t4;
  /* In range? */
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;
  t4 = (t8 & 0xff) << ((t3&7)*8);
  t1 = t1 & ~(0xffL << (t3&7)*8);

g8254:
  if (_trace) printf("g8254:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);
  *(u32 *)t5 = t6;
  /* J. if in cache */
  if (t10 != 0)
    goto g8253;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g8252:
  if (_trace) printf("g8252:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

g8251:
  if (_trace) printf("g8251:\n");

pdpbillop:
  if (_trace) printf("pdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = iSP - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

g8253:
  if (_trace) printf("g8253:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);

g8258:
  if (_trace) printf("g8258:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t4 = t2 - t4;
  /* reconstruct SCA */
  t3 = (t4 * 8) + t3;
  /* Store in stack */
  *(u32 *)t3 = t6;
  /* write the stack cache */
  *(u32 *)(t3 + 4) = t8;
  goto NEXTINSTRUCTION;

g8244:
  if (_trace) printf("g8244:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  t6 = *(s32 *)t3;
  /* Read from stack cache */
  t8 = *(s32 *)(t3 + 4);
  goto g8243;

/* end DoPDpb */
  /* End of Halfword operand from stack instruction - DoPDpb */
/* start DoPTagDpb */

  /* Field Extraction instruction - DoPTagDpb */

doptagdpb:
  if (_trace) printf("doptagdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPTagDpbIM:
  if (_trace) printf("DoPTagDpbIM:\n");

DoPTagDpbSP:
  if (_trace) printf("DoPTagDpbSP:\n");

DoPTagDpbLP:
  if (_trace) printf("DoPTagDpbLP:\n");

DoPTagDpbFP:
  if (_trace) printf("DoPTagDpbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  /* Get arg2 tag/data */
  t2 = *(s32 *)iSP;
  /* Get arg2 tag/data */
  t1 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = (u32)t2;
  t3 = t1 - Type_PhysicalAddress;
  t3 = t3 & 63;
  if (t3 == 0)
    goto ptagdpbillop;
  /* get arg1 tag/data */
  arg4 = *(s32 *)iSP;
  /* get arg1 tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* Memory Read Internal */

g8259:
  /* Base of stack cache */
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;
  t8 = (t1 * 4);
  t6 = LDQ_U(t1);
  /* Stack cache offset */
  t3 = t2 - t3;
  /* In range? */
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;
  t8 = *(s32 *)t8;
  t6 = (u8)(t6 >> ((t1&7)*8));
  if (t4 != 0)
    goto g8261;

g8260:

g8267:
  /* Strip off any CDR code bits. */
  t1 = arg3 & 63;
  t10 = (t1 == Type_Fixnum) ? 1 : 0;

g8274:
  if (_trace) printf("g8274:\n");
  if (t10 == 0)
    goto g8269;
  /* Here if argument TypeFixnum */
  /* t7= -2 */
  t7 = zero - 2;
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* reuse t5 as mask */
  t5 = ~t7;
  /* T3= masked new value. */
  t3 = arg4 & ~t7;
  /* t5 is the inplace mask */
  t5 = t5 << (arg2 & 63);
  /* t4 is the shifted field */
  t4 = t3 << (arg2 & 63);
  /* Clear out existing bits in arg2 field */
  t6 = t6 & ~t5;
  /* Put the new bits in */
  t6 = t4 | t6;
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;
  t5 = (t3 * 4);
  t1 = LDQ_U(t3);
  /* Stack cache offset */
  t4 = t2 - t4;
  /* In range? */
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;
  t4 = (t6 & 0xff) << ((t3&7)*8);
  t1 = t1 & ~(0xffL << (t3&7)*8);

g8271:
  if (_trace) printf("g8271:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);
  *(u32 *)t5 = t8;
  /* J. if in cache */
  if (t10 != 0)
    goto g8270;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g8269:
  if (_trace) printf("g8269:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

g8268:
  if (_trace) printf("g8268:\n");

ptagdpbillop:
  if (_trace) printf("ptagdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = iSP - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

g8270:
  if (_trace) printf("g8270:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);

g8275:
  if (_trace) printf("g8275:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t4 = t2 - t4;
  /* reconstruct SCA */
  t3 = (t4 * 8) + t3;
  /* Store in stack */
  *(u32 *)t3 = t8;
  /* write the stack cache */
  *(u32 *)(t3 + 4) = t6;
  goto NEXTINSTRUCTION;

g8261:
  if (_trace) printf("g8261:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  t8 = *(s32 *)t3;
  /* Read from stack cache */
  t6 = *(s32 *)(t3 + 4);
  goto g8260;

/* end DoPTagDpb */
  /* End of Halfword operand from stack instruction - DoPTagDpb */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfext.as */
