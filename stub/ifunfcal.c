/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunfcal.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Function calling. */
  /* Start call. */
  /* Finish call. */
/* start DoFinishCallTos */

  /* Halfword 10 bit immediate instruction - DoFinishCallTos */

dofinishcalltos:
  if (_trace) printf("dofinishcalltos:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoFinishCallTosIM:
  if (_trace) printf("DoFinishCallTosIM:\n");

DoFinishCallTosSP:
  if (_trace) printf("DoFinishCallTosSP:\n");

DoFinishCallTosLP:
  if (_trace) printf("DoFinishCallTosLP:\n");

DoFinishCallTosFP:
  if (_trace) printf("DoFinishCallTosFP:\n");
  /* arg1 has operand preloaded. */
  /* arg1 contains the disposition (two bits) */
  arg1 = (u8)(arg3 >> ((5&7)*8));
  /* Get the number of args */
  arg2 = *(s32 *)iSP;
  /* Pop stack */
  iSP = iSP - 8;
  /* Add 1 and convert to stacked word address */
  arg2 = (arg2 * 8) + 8;
  goto finishcallmerge;

/* end DoFinishCallTos */
  /* End of Halfword operand from stack instruction - DoFinishCallTos */
  /* Function entry. */
/* start DoEntryRestAccepted */

  /* Field Extraction instruction - DoEntryRestAccepted */

doentryrestaccepted:
  if (_trace) printf("doentryrestaccepted:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoEntryRestAcceptedIM:
  if (_trace) printf("DoEntryRestAcceptedIM:\n");

DoEntryRestAcceptedSP:
  if (_trace) printf("DoEntryRestAcceptedSP:\n");

DoEntryRestAcceptedLP:
  if (_trace) printf("DoEntryRestAcceptedLP:\n");

DoEntryRestAcceptedFP:
  if (_trace) printf("DoEntryRestAcceptedFP:\n");
  /* The control register */
  arg5 = *(s32 *)&processor->control;
  /* Pull down the number of optionals */
  arg4 = arg3 >> 18;
  /* Extract the 'ptr' field while we are waiting */
  arg1 = (u8)(arg3 >> ((5&7)*8));
  arg4 = arg4 & 255;
  /* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
  /* Get the cr.trace-pending bit */
  t2 = arg5 >> 27;
  /* The supplied args */
  t1 = arg5 & 255;
  if (t2 & 1)
    goto tracetrap;
  t3 = arg5 >> 17;
  /* Get the tag of the stack top. */
  t4 = *(s32 *)(iSP + 4);

g6971:
  if (_trace) printf("g6971:\n");
  /* J. if apply args */
  if (t3 & 1)
    goto g6969;

g6970:
  /* t2=supplied-minimum */
  t2 = t1 - arg2;
  /* B. if too few args. */
  if ((s64)t2 < 0)
    goto retryeratoofew;
  /* maximum-supplied */
  arg1 = arg4 - t1;
  /* B. rest args. */
  if ((s64)arg1 < 0)
    goto retryerarest;
  /* Compute entry position and advance PC/CP accordingly. */
  /* get the next PC */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Adjust index to halfword */
  t3 = t2 << 1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* J. if index zero, no adjustment. */
  if (t2 == 0)
    goto INTERPRETINSTRUCTION;
  /* Compute the new address */
  iPC = iPC + t3;
  /* Make it an DTP-EVEN-PC */
  iPC = iPC & ~1L;
  goto interpretinstructionforjump;

applysuppra:
  if (_trace) printf("applysuppra:\n");
  /* maximum-supplied */
  arg1 = arg4 - t1;
  /* B. rest args. */
  if ((s64)arg1 < 0)
    goto retryerarest;
  /* try pulling from applied args. */
  if ((s64)arg1 > 0)
    goto pullapplyargs;
  /* get tag */
  t6 = *(s32 *)(iSP + 4);
  t6 = t6 & 63;
  t6 = t6 | 64;
  /* set tag */
  *(u32 *)(iSP + 4) = t6;
  /* t2=supplied-minimum */
  t2 = t1 - arg2;
  t2 = t2 + 1;
  /* Compute entry position and advance PC/CP accordingly. */
  /* get the next PC */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Adjust index to halfword */
  t3 = t2 << 1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* J. if index zero, no adjustment. */
  if (t2 == 0)
    goto INTERPRETINSTRUCTION;
  /* Compute the new address */
  iPC = iPC + t3;
  /* Make it an DTP-EVEN-PC */
  iPC = iPC & ~1L;
  goto interpretinstructionforjump;

retryeratoofew:
  if (_trace) printf("retryeratoofew:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

retryerarest:
  if (_trace) printf("retryerarest:\n");
  /* get tag */
  t1 = *(s32 *)(iSP + 4);
  t1 = t1 & 63;
  t1 = t1 | 64;
  /* set tag */
  *(u32 *)(iSP + 4) = t1;
  t2 = arg5 >> 17;
  /* Get the tag of the stack top. */
  t3 = *(s32 *)(iSP + 4);

g6976:
  if (_trace) printf("g6976:\n");
  /* J. if apply args */
  if (t2 & 1)
    goto g6974;

g6975:
  t1 = (arg4 * 8) + iFP;
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t3 = t1 - t3;
  /* convert byte address to word address */
  t3 = t3 >> 3;
  /* reconstruct VMA */
  t2 = t3 + t2;
  t1 = Type_List;
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto g6973;

g6972:
  if (_trace) printf("g6972:\n");
  t1 = iSP - 8;
  /* get tag */
  t3 = *(s32 *)(t1 + 4);
  t3 = t3 & 63;
  t3 = t3 | 128;
  /* set tag */
  *(u32 *)(t1 + 4) = t3;
  t1 = (arg4 * 8) + iFP;
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t3 = t1 - t3;
  /* convert byte address to word address */
  t3 = t3 >> 3;
  /* reconstruct VMA */
  t2 = t3 + t2;
  t1 = Type_List;
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  iLP = iLP + 8;
  arg5 = arg5 + 1;
  *(u32 *)&processor->control = arg5;

g6973:
  if (_trace) printf("g6973:\n");
  t1 = arg4 - arg2;
  t1 = t1 + 1;
  /* Compute entry position and advance PC/CP accordingly. */
  /* get the next PC */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Adjust index to halfword */
  t2 = t1 << 1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* J. if index zero, no adjustment. */
  if (t1 == 0)
    goto INTERPRETINSTRUCTION;
  /* Compute the new address */
  iPC = iPC + t2;
  /* Make it an DTP-EVEN-PC */
  iPC = iPC & ~1L;
  goto interpretinstructionforjump;

g6974:
  if (_trace) printf("g6974:\n");
  t3 = t3 & 63;
  t3 = t3 - Type_NIL;
  /* J. if apply args supplied not nil. */
  if (t3 != 0)
    goto g6972;
  /* keep just the apply bit! */
  t2 = t2 & 1;
  /* reposition the apply bit */
  t2 = t2 << 17;
  /* Pop off the null applied arg. */
  iSP = iSP - 8;
  /* Blast the apply arg bit away */
  arg5 = arg5 & ~t2;
  /* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto g6975;

g6969:
  if (_trace) printf("g6969:\n");
  t4 = t4 & 63;
  t4 = t4 - Type_NIL;
  /* J. if apply args supplied not nil. */
  if (t4 != 0)
    goto applysuppra;
  /* keep just the apply bit! */
  t3 = t3 & 1;
  /* reposition the apply bit */
  t3 = t3 << 17;
  /* Pop off the null applied arg. */
  iSP = iSP - 8;
  /* Blast the apply arg bit away */
  arg5 = arg5 & ~t3;
  /* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto g6970;

/* end DoEntryRestAccepted */
  /* End of Halfword operand from stack instruction - DoEntryRestAccepted */
/* start CarCdrInternal */


carcdrinternal:
  if (_trace) printf("carcdrinternal:\n");
  sp = sp + -8;
  arg2 = (u32)(t2 >> ((zero&7)*8));
  /* Strip off any CDR code bits. */
  t5 = t1 & 63;
  t6 = (t5 == Type_List) ? 1 : 0;

g7024:
  if (_trace) printf("g7024:\n");
  if (t6 == 0)
    goto g6981;
  /* Here if argument TypeList */
  /* Memory Read Internal */

g6982:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6984;

g6983:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6986;

g6993:
  t5 = (s32)arg2 - (s32)t2;
  /* CAR forwarded, must CDR the hard way */
  if (t5 != 0)
    goto g6977;
  t1 = arg5;
  t2 = arg6;

g6979:
  if (_trace) printf("g6979:\n");
  /* Extract CDR code. */
  t5 = arg5 & 192;
  if (t5 != 0)
    goto g6995;
  /* Here if argument 0 */
  /* Address of next position is CDR */
  arg6 = arg2 + 1;
  arg5 = Type_List;

g6994:
  if (_trace) printf("g6994:\n");

g6980:
  if (_trace) printf("g6980:\n");

g6978:
  if (_trace) printf("g6978:\n");
  sp = sp + 8;
  goto *((void* )r0); /* ret */

g6981:
  if (_trace) printf("g6981:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;

g7025:
  if (_trace) printf("g7025:\n");
  if (t6 == 0)
    goto g7011;
  /* Here if argument TypeNIL */
  arg6 = *(s32 *)&processor->niladdress;
  arg5 = *((s32 *)(&processor->niladdress)+1);
  arg6 = (u32)arg6;
  goto g6980;

g7011:
  if (_trace) printf("g7011:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto listexception;

g6977:
  if (_trace) printf("g6977:\n");
  arg2 = (u32)(t2 >> ((zero&7)*8));
  t1 = arg5;
  t2 = arg6;
  /* Memory Read Internal */

g7013:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->cdr_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7015;

g7014:
  t7 = zero + 192;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g7017;

g7022:
  goto g6979;

g7017:
  if (_trace) printf("g7017:\n");
  if ((t7 & 1) == 0)
    goto g7016;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g7013;

g7016:
  if (_trace) printf("g7016:\n");

g7015:
  if (_trace) printf("g7015:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0036;
  goto memoryreadcdrdecode;
return0036:
  r0 = *(u64 *)sp;
  goto g7022;

g6995:
  if (_trace) printf("g6995:\n");
  t6 = (t5 == 128) ? 1 : 0;

g7026:
  if (_trace) printf("g7026:\n");
  if (t6 == 0)
    goto g6996;
  /* Here if argument 128 */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6997:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6999;

g6998:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g7001;
  goto g6978;

g6996:
  if (_trace) printf("g6996:\n");
  t6 = (t5 == 64) ? 1 : 0;

g7027:
  if (_trace) printf("g7027:\n");
  if (t6 == 0)
    goto g7008;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;
  arg5 = *((s32 *)(&processor->niladdress)+1);
  arg6 = (u32)arg6;
  goto g6978;

g7008:
  if (_trace) printf("g7008:\n");
  /* Here for all other cases */
  arg5 = arg2;
  arg2 = 15;
  goto illegaloperand;

g7001:
  if (_trace) printf("g7001:\n");
  if ((t7 & 1) == 0)
    goto g7000;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6997;

g7000:
  if (_trace) printf("g7000:\n");

g6999:
  if (_trace) printf("g6999:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0037;
  goto memoryreaddatadecode;
return0037:
  r0 = *(u64 *)sp;
  goto g6978;

g6986:
  if (_trace) printf("g6986:\n");
  if ((t7 & 1) == 0)
    goto g6985;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6982;

g6985:
  if (_trace) printf("g6985:\n");

g6984:
  if (_trace) printf("g6984:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0038;
  goto memoryreaddatadecode;
return0038:
  r0 = *(u64 *)sp;
  goto g6993;

/* end CarCdrInternal */
/* start PullApplyArgsSlowly */


pullapplyargsslowly:
  if (_trace) printf("pullapplyargsslowly:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Get the rest arg */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  t2 = (u32)(arg4 >> ((zero&7)*8));
  /* Strip off any CDR code bits. */
  t3 = arg3 & 63;
  t4 = (t3 == Type_List) ? 1 : 0;

g7075:
  if (_trace) printf("g7075:\n");
  if (t4 == 0)
    goto g7032;
  /* Here if argument TypeList */
  /* Memory Read Internal */

g7033:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);
  arg5 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = t2 - t11;
  t6 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t5&7)*8));
  if (t4 != 0)
    goto g7035;

g7034:
  t5 = zero + 240;
  t6 = t6 >> (arg5 & 63);
  t5 = t5 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t6 & 1)
    goto g7037;

g7044:
  t3 = (s32)t2 - (s32)arg4;
  /* CAR forwarded, must CDR the hard way */
  if (t3 != 0)
    goto g7028;
  arg3 = arg5;
  arg4 = arg6;

g7030:
  if (_trace) printf("g7030:\n");
  /* Extract CDR code. */
  t3 = arg5 & 192;
  if (t3 != 0)
    goto g7046;
  /* Here if argument 0 */
  /* Address of next position is CDR */
  arg6 = t2 + 1;
  arg5 = Type_List;

g7045:
  if (_trace) printf("g7045:\n");

g7031:
  if (_trace) printf("g7031:\n");

g7029:
  if (_trace) printf("g7029:\n");
  /* Push the pulled argument */
  *(u32 *)iSP = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = arg3;
  /* set CDR-NEXT */
  t1 = arg5 & 63;
  /* Push the new rest arg */
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  arg2 = *(s32 *)&processor->control;
  /* Get current arg size. */
  t2 = arg2 & 255;
  arg2 = arg2 & ~255L;
  t2 = t2 + 1;
  /* Update the arg size */
  arg2 = t2 + arg2;
  *(u32 *)&processor->control = arg2;
  iLP = iLP + 8;
  goto INTERPRETINSTRUCTION;

g7032:
  if (_trace) printf("g7032:\n");
  t4 = (t3 == Type_NIL) ? 1 : 0;

g7076:
  if (_trace) printf("g7076:\n");
  if (t4 == 0)
    goto g7062;
  /* Here if argument TypeNIL */
  arg6 = *(s32 *)&processor->niladdress;
  arg5 = *((s32 *)(&processor->niladdress)+1);
  arg6 = (u32)arg6;
  goto g7031;

g7062:
  if (_trace) printf("g7062:\n");
  /* Here for all other cases */
  arg1 = arg1;
  goto pullapplyargstrap;

g7028:
  if (_trace) printf("g7028:\n");
  t2 = (u32)(arg4 >> ((zero&7)*8));
  arg3 = arg5;
  arg4 = arg6;
  /* Memory Read Internal */

g7064:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);
  arg5 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = t2 - t11;
  t6 = *(u64 *)&(processor->cdr_mask);
  /* In range? */
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t5&7)*8));
  if (t4 != 0)
    goto g7066;

g7065:
  t5 = zero + 192;
  t6 = t6 >> (arg5 & 63);
  t5 = t5 >> (arg5 & 63);
  if (t6 & 1)
    goto g7068;

g7073:
  goto g7030;

g7066:
  if (_trace) printf("g7066:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  arg6 = *(s32 *)t3;
  /* Read from stack cache */
  arg5 = *(s32 *)(t3 + 4);
  goto g7065;

g7068:
  if (_trace) printf("g7068:\n");
  if ((t5 & 1) == 0)
    goto g7067;
  /* Do the indirect thing */
  t2 = (u32)arg6;
  goto g7064;

g7067:
  if (_trace) printf("g7067:\n");
  /* Load the memory action table for cycle */
  t6 = *(u64 *)&(processor->cdr);
  /* TagType. */
  /* Discard the CDR code */
  t5 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t5 = (t5 * 4) + t6;
  /* Get the memory action */
  t6 = *(s32 *)t5;

g7070:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 9;
  goto performmemoryaction;

g7046:
  if (_trace) printf("g7046:\n");
  t4 = (t3 == 128) ? 1 : 0;

g7077:
  if (_trace) printf("g7077:\n");
  if (t4 == 0)
    goto g7047;
  /* Here if argument 128 */
  t2 = t2 + 1;
  /* Memory Read Internal */

g7048:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);
  arg5 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = t2 - t11;
  t6 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t5&7)*8));
  if (t4 != 0)
    goto g7050;

g7049:
  t5 = zero + 240;
  t6 = t6 >> (arg5 & 63);
  t5 = t5 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t6 & 1)
    goto g7052;
  goto g7029;

g7047:
  if (_trace) printf("g7047:\n");
  t4 = (t3 == 64) ? 1 : 0;

g7078:
  if (_trace) printf("g7078:\n");
  if (t4 == 0)
    goto g7059;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;
  arg5 = *((s32 *)(&processor->niladdress)+1);
  arg6 = (u32)arg6;
  goto g7029;

g7059:
  if (_trace) printf("g7059:\n");
  /* Here for all other cases */
  arg5 = t2;
  arg2 = 15;
  goto illegaloperand;

g7050:
  if (_trace) printf("g7050:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  arg6 = *(s32 *)t3;
  /* Read from stack cache */
  arg5 = *(s32 *)(t3 + 4);
  goto g7049;

g7052:
  if (_trace) printf("g7052:\n");
  if ((t5 & 1) == 0)
    goto g7051;
  /* Do the indirect thing */
  t2 = (u32)arg6;
  goto g7048;

g7051:
  if (_trace) printf("g7051:\n");
  /* Load the memory action table for cycle */
  t6 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t5 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t5 = (t5 * 4) + t6;
  /* Get the memory action */
  t6 = *(s32 *)t5;

g7056:
  if (_trace) printf("g7056:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0)
    goto g7055;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g7029;
#ifndef MINIMA

g7055:
#endif
#ifdef MINIMA

g7055:
  if (_trace) printf("g7055:\n");
  t5 = t6 & MemoryActionBinding;
  t4 = *(u64 *)&(processor->dbcmask);
  if (t5 == 0)
    goto g7054;
  t3 = t2 << 1;
  t5 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t3 = t3 & t4;
  t4 = 1;
  t4 = t4 << (ivorymemorydata & 63);
  t3 = (s32)t3 + (s32)t5;
  /* Clear sign-extension */
  t3 = (u32)t3;
  t4 = (t3 * 4) + t4;
  /* Fetch the key */
  t3 = *(s32 *)t4;
  /* Fetch value */
  arg6 = *(s32 *)(t4 + 4);
  /* Compare */
  t5 = (s32)t2 - (s32)t3;
  /* Trap on miss */
  if (t5 != 0)
    goto g7058;
  /* Extract the pointer, and indirect */
  t2 = (u32)arg6;
  goto g7048;

g7058:
  if (_trace) printf("g7058:\n");
  goto dbcachemisstrap;
#endif

g7054:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

g7035:
  if (_trace) printf("g7035:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  arg6 = *(s32 *)t3;
  /* Read from stack cache */
  arg5 = *(s32 *)(t3 + 4);
  goto g7034;

g7037:
  if (_trace) printf("g7037:\n");
  if ((t5 & 1) == 0)
    goto g7036;
  /* Do the indirect thing */
  t2 = (u32)arg6;
  goto g7033;

g7036:
  if (_trace) printf("g7036:\n");
  /* Load the memory action table for cycle */
  t6 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t5 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t5 = (t5 * 4) + t6;
  /* Get the memory action */
  t6 = *(s32 *)t5;

g7041:
  if (_trace) printf("g7041:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0)
    goto g7040;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g7044;
#ifndef MINIMA

g7040:
#endif
#ifdef MINIMA

g7040:
  if (_trace) printf("g7040:\n");
  t5 = t6 & MemoryActionBinding;
  t4 = *(u64 *)&(processor->dbcmask);
  if (t5 == 0)
    goto g7039;
  t3 = t2 << 1;
  t5 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t3 = t3 & t4;
  t4 = 1;
  t4 = t4 << (ivorymemorydata & 63);
  t3 = (s32)t3 + (s32)t5;
  /* Clear sign-extension */
  t3 = (u32)t3;
  t4 = (t3 * 4) + t4;
  /* Fetch the key */
  t3 = *(s32 *)t4;
  /* Fetch value */
  arg6 = *(s32 *)(t4 + 4);
  /* Compare */
  t5 = (s32)t2 - (s32)t3;
  /* Trap on miss */
  if (t5 != 0)
    goto g7043;
  /* Extract the pointer, and indirect */
  t2 = (u32)arg6;
  goto g7033;

g7043:
  if (_trace) printf("g7043:\n");
  goto dbcachemisstrap;
#endif

g7039:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

/* end PullApplyArgsSlowly */
/* start DoLocateLocals */

  /* Halfword operand from stack instruction - DoLocateLocals */
  /* arg2 has the preloaded 8 bit operand. */

dolocatelocals:
  if (_trace) printf("dolocatelocals:\n");
#ifdef TRACING
#endif

DoLocateLocalsSP:
  if (_trace) printf("DoLocateLocalsSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindolocatelocals;
#endif

DoLocateLocalsLP:
  if (_trace) printf("DoLocateLocalsLP:\n");
#ifdef TRACING
  goto begindolocatelocals;
#endif

DoLocateLocalsFP:
  if (_trace) printf("DoLocateLocalsFP:\n");

begindolocatelocals:
  if (_trace) printf("begindolocatelocals:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* The control register */
  t1 = *(s32 *)&processor->control;
  iLP = iSP;
  /* arg size including the fudge 2 */
  t3 = iLP - iFP;
  /* adjust arg size to words */
  t3 = t3 >> 3;
  /* argument size */
  t2 = t1 & 255;
  /* corrected arg size */
  t2 = t2 - 2;
  t1 = t1 & ~255L;
  /* replace the arg size */
  t1 = t1 | t3;
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  *(u32 *)&processor->control = t1;
  goto NEXTINSTRUCTION;
#ifdef TRACING
#endif

DoLocateLocalsIM:
  goto doistageerror;

/* end DoLocateLocals */
  /* End of Halfword operand from stack instruction - DoLocateLocals */
  /* Returning. */
/* start DoReturnMultiple */

  /* Halfword operand from stack instruction - DoReturnMultiple */
  /* arg2 has the preloaded 8 bit operand. */

doreturnmultiple:
  if (_trace) printf("doreturnmultiple:\n");
#ifdef TRACING
#endif

DoReturnMultipleSP:
  if (_trace) printf("DoReturnMultipleSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoreturnmultiple;
#endif

DoReturnMultipleLP:
  if (_trace) printf("DoReturnMultipleLP:\n");
#ifdef TRACING
  goto begindoreturnmultiple;
#endif

DoReturnMultipleFP:
  if (_trace) printf("DoReturnMultipleFP:\n");

begindoreturnmultiple:
  if (_trace) printf("begindoreturnmultiple:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Fetch the tag for type-check */
  t1 = *(s32 *)(arg1 + 4);
  /* Fetch the data */
  arg1 = *(s32 *)arg1;
  t2 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t2 = t2 & 63;
  if (t2 != 0)
    goto returnmultipleio;
  /* Discard dtp-fixnum tag word */
  arg1 = (u32)arg1;

returnmultipletop:
  if (_trace) printf("returnmultipletop:\n");
  arg5 = *(s32 *)&processor->control;
  t3 = (12) << 16;
  t2 = iSP + 8;
  /* Value bytes */
  t1 = arg1 << 3;
  /* Mask */
  t3 = t3 & arg5;
  /* Shift disposition bits into place. */
  t3 = t3 >> 18;
  /* Compute position of value(s) */
  arg3 = t2 - t1;
  arg6 = *(u64 *)&(processor->stackcachedata);
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  arg4 = t3 - 2;
  if ((s64)arg4 < 0)
    goto returnmultiplesingle;
  /* Restore machine state from frame header. */
  t3 = *(s32 *)iFP;
  t1 = (1792) << 16;
  t5 = *(s32 *)&processor->continuation;
  /* Mask */
  t1 = arg5 & t1;
  t2 = *(s32 *)(iFP + 4);
  t7 = iCP;
  /* Need to cleanup frame first */
  if (t1 != 0)
    goto handleframecleanup;
  t3 = (u32)t3;
  t4 = *((s32 *)(&processor->continuation)+1);
  t5 = (u32)t5;
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  /* check for end of run */
  t6 = (s32)t2 - (s32)Type_NIL;
  if (t6 == 0)
    goto g7079;
#endif
  /* Get saved control register */
  t6 = *(s32 *)(iFP + 8);
  /* TagType. */
  t2 = t2 & 63;
  /* Restore the PC. */
  if (arg4 == 0)
    goto g7081;
  /* Assume even PC */
  iPC = t5 << 1;
  t1 = t4 & 1;
  t7 = *(u64 *)&(processor->continuationcp);
  iPC = iPC + t1;

g7081:
  if (_trace) printf("g7081:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t2;
  /* Get the caller frame size into place */
  t1 = arg5 >> 9;
  *(u32 *)&processor->continuation = t3;
  /* Restore the stack pointer. */
  iSP = iFP - 8;
  *(u64 *)&processor->continuationcp = zero;
  /* Mask just the caller frame size. */
  t1 = t1 & 255;
  /* *8 */
  t1 = (t1 * 8) + 0;
  t2 = (2048) << 16;
  t2 = t2 & arg5;
  /* Get the preempt-pending bit */
  t3 = *(s32 *)&processor->interruptreg;
  /* Sticky trace pending bit. */
  t6 = t2 | t6;
  /* Get the trap/suspend bits */
  t4 = *(u64 *)&(processor->please_stop);
  /* Restore the frame pointer. */
  iFP = iFP - t1;
  /* Restore the control register */
  *(u32 *)&processor->control = t6;
  /* extract the argument size */
  t1 = t6 & 255;
  t3 = t3 & 1;
  t3 = t4 | t3;
  *(u64 *)&processor->stop_interpreter = t3;
  /* Restore the local pointer. */
  iLP = (t1 * 8) + iFP;
  /* ARG6 = stack-cache underflow */
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;
  /* Compute destination of copy */
  t4 = iSP + 8;
  /* Values */
  t3 = arg1;
  /* mask for CDR codes */
  t1 = *(u64 *)&(processor->cdrcodemask);
  goto g7082;

g7083:
  if (_trace) printf("g7083:\n");
  t3 = t3 - 1;
  /* Get a word from source */
  t2 = *(u64 *)arg3;
  /* advance from position */
  arg3 = arg3 + 8;
  /* Strip off CDR code */
  t2 = t2 & ~t1;
  /* Put word in destination */
  *(u64 *)t4 = t2;
  /* advance to position */
  t4 = t4 + 8;

g7082:
  if ((s64)t3 > 0)
    goto g7083;
  /* Adjust iSP over returned values */
  iSP = (arg1 * 8) + iSP;
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  if (arg4 == 0)
    goto returnmultiplereturn;

returnmultiplemultiple:
  if (_trace) printf("returnmultiplemultiple:\n");
  t1 = Type_Fixnum;
  /* push the MV return count */
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;

returnmultipledone:
  if (_trace) printf("returnmultipledone:\n");
  if (arg6 != 0)
    goto returnmultipleunderflow;
  arg2 = t7;
  if (t7 != 0)
    goto interpretinstructionpredicted;
  if (arg4 != 0)
    goto interpretinstructionforbranch;
  goto INTERPRETINSTRUCTION;

returnmultipleunderflow:
  if (_trace) printf("returnmultipleunderflow:\n");
  goto stackcacheunderflowcheck;

returnmultiplesingle:
  if (_trace) printf("returnmultiplesingle:\n");
  arg3 = *(u64 *)arg3;
  t1 = *(u64 *)&(processor->niladdress);
  /* Clear cdr */
  arg3 = arg3 << 26;
  /* Clear cdr */
  arg3 = arg3 >> 26;
  if (arg1 == 0)
    arg3 = t1;
  goto returncommontail;

returnmultiplereturn:
  if (_trace) printf("returnmultiplereturn:\n");
  if (arg2 != 0)
    goto returnmultipledone;
  t1 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto returnmultipledone;
#ifdef TRACING
  goto DoReturnMultipleIM;
#endif

DoReturnMultipleIM:
  if (_trace) printf("DoReturnMultipleIM:\n");
  arg1 = arg2;
  arg2 = zero + 1;
  goto returnmultipletop;

returnmultipleio:
  if (_trace) printf("returnmultipleio:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoReturnMultiple */
  /* End of Halfword operand from stack instruction - DoReturnMultiple */
/* start HANDLEFRAMECLEANUP */


handleframecleanup:
  if (_trace) printf("handleframecleanup:\n");
  /* Restore SP to instruction start */
  iSP = *(u64 *)&(processor->restartsp);
  /* Get control register */
  arg5 = *(s32 *)&processor->control;

g7086:
  if (_trace) printf("g7086:\n");
  t1 = (1024) << 16;
  t4 = *(s32 *)&processor->catchblock;
  t4 = (u32)t4;
  t2 = t1 & arg5;
  /* J. if cr.cleanup-catch is 0 */
  if (t2 == 0)
    goto g7085;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t3 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t2 = t4 - t2;
  /* reconstruct SCA */
  t3 = (t2 * 8) + t3;
  t6 = *(s32 *)(t3 + 16);
  t5 = *(s32 *)(t3 + 20);
  t6 = (u32)t6;
  t2 = *(s32 *)(t3 + 8);
  t1 = *(s32 *)(t3 + 12);
  t2 = (u32)t2;
  t12 = t1 & 64;
  /* J. if catch block is UWP variety. */
  if (t12 != 0)
    goto handleunwindprotect;
  t3 = (1024) << 16;
  /* Extract the catchcleanup bit */
  t2 = t5 & 64;
  /* Shift into place for CR */
  t2 = t2 << 20;
  t3 = arg5 & ~t3;
  arg5 = t3 | t2;
  *(u32 *)&processor->control = arg5;
  /* TagType. */
  t5 = t5 & 63;
  t5 = t5 << 32;
  t6 = t6 | t5;
  *(u64 *)&processor->catchblock = t6;
  goto g7086;

g7085:
  if (_trace) printf("g7085:\n");
  t1 = (512) << 16;
  t2 = t1 & arg5;
  t1 = *(u64 *)&(processor->bindingstackpointer);
  /* J. if cr.cleanup-bindings is 0. */
  if (t2 == 0)
    goto g7084;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t4 = t1 >> 32;
  t3 = t4 - Type_Locative;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto dbunwindframetrap;
#endif

g7087:
  if (_trace) printf("g7087:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);
  t4 = *(s32 *)&processor->control;
  /* vma only */
  t1 = (u32)t1;
  t2 = (512) << 16;
  t5 = t1 - 1;
  t3 = t4 & t2;
  /* Turn off the bit */
  t4 = t4 & ~t2;
  if (t3 != 0)
    goto g7088;
  /* Get the SP, ->op2 */
  t4 = *(u64 *)&(processor->restartsp);
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g7088:
  if (_trace) printf("g7088:\n");
  /* Memory Read Internal */

g7089:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t6 = (t10 * 4);
  t7 = LDQ_U(t10);
  /* Stack cache offset */
  t8 = t1 - t8;
  t11 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t10&7)*8));
  if (t9 != 0)
    goto g7091;

g7090:
  t10 = zero + 224;
  t11 = t11 >> (t7 & 63);
  t10 = t10 >> (t7 & 63);
  if (t11 & 1)
    goto g7093;

g7098:
  /* Memory Read Internal */

g7099:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t2 = (t10 * 4);
  t3 = LDQ_U(t10);
  /* Stack cache offset */
  t8 = t5 - t8;
  t11 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  t2 = *(s32 *)t2;
  t3 = (u8)(t3 >> ((t10&7)*8));
  if (t9 != 0)
    goto g7101;

g7100:
  t10 = zero + 224;
  t11 = t11 >> (t3 & 63);
  t10 = t10 >> (t3 & 63);
  t2 = (u32)t2;
  if (t11 & 1)
    goto g7103;

g7108:
  /* Memory Read Internal */

g7109:
  /* Base of stack cache */
  t10 = *(u64 *)&(processor->stackcachebasevma);
  t12 = t2 + ivory;
  t11 = *(s32 *)&processor->scovlimit;
  t9 = (t12 * 4);
  t8 = LDQ_U(t12);
  /* Stack cache offset */
  t10 = t2 - t10;
  /* In range? */
  t11 = ((u64)t10 < (u64)t11) ? 1 : 0;
  t9 = *(s32 *)t9;
  t8 = (u8)(t8 >> ((t12&7)*8));
  if (t11 != 0)
    goto g7111;

g7110:
  t10 = *(u64 *)&(processor->bindwrite_mask);
  t12 = zero + 224;
  t10 = t10 >> (t8 & 63);
  t12 = t12 >> (t8 & 63);
  if (t10 & 1)
    goto g7113;

g7118:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  t10 = t2 + ivory;
  t9 = (t10 * 4);
  t12 = LDQ_U(t10);
  t11 = (t8 & 0xff) << ((t10&7)*8);
  t12 = t12 & ~(0xffL << (t10&7)*8);

g7121:
  if (_trace) printf("g7121:\n");
  t12 = t12 | t11;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  STQ_U(t10, t12);
  t10 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  t11 = t2 - t11;
  /* In range? */
  t10 = ((u64)t11 < (u64)t10) ? 1 : 0;
  *(u32 *)t9 = t6;
  /* J. if in cache */
  if (t10 != 0)
    goto g7120;

g7119:
  /* Get the old cleanup-bindings bit */
  t3 = t3 & 64;
  t3 = t3 << 19;
  t1 = t1 - 2;
  /* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  arg5 = *(s32 *)&processor->control;
  t1 = (512) << 16;
  t2 = t1 & arg5;
  /* J. if cr.cleanup-bindings is 0. */
  if (t2 != 0)
    goto g7087;
  t2 = *(s32 *)&processor->interruptreg;
  t3 = t2 & 2;
  t3 = (t3 == 2) ? 1 : 0;
  t2 = t2 | t3;
  *(u32 *)&processor->interruptreg = t2;
  if (t2 == 0)
    goto g7122;
  *(u64 *)&processor->stop_interpreter = t2;

g7122:
  if (_trace) printf("g7122:\n");

g7084:
  if (_trace) printf("g7084:\n");
  t3 = (256) << 16;
  t2 = t3 & arg5;
  if (t2 == 0)
    goto INTERPRETINSTRUCTION;
  arg5 = zero;
  arg2 = 79;
  goto illegaloperand;
  goto INTERPRETINSTRUCTION;

g7120:
  if (_trace) printf("g7120:\n");
  t10 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t10 = (t11 * 8) + t10;
  /* Store in stack */
  *(u32 *)t10 = t6;
  /* write the stack cache */
  *(u32 *)(t10 + 4) = t8;
  goto g7119;

g7111:
  if (_trace) printf("g7111:\n");
  t11 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t10 = (t10 * 8) + t11;
  t9 = *(s32 *)t10;
  /* Read from stack cache */
  t8 = *(s32 *)(t10 + 4);
  goto g7110;

g7113:
  if (_trace) printf("g7113:\n");
  if ((t12 & 1) == 0)
    goto g7112;
  /* Do the indirect thing */
  t2 = (u32)t9;
  goto g7109;

g7112:
  if (_trace) printf("g7112:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->bindwrite);
  /* TagType. */
  /* Discard the CDR code */
  t12 = t8 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t12 = (t12 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t12;

g7115:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

g7101:
  if (_trace) printf("g7101:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  t2 = *(s32 *)t8;
  /* Read from stack cache */
  t3 = *(s32 *)(t8 + 4);
  goto g7100;

g7103:
  if (_trace) printf("g7103:\n");
  if ((t10 & 1) == 0)
    goto g7102;
  /* Do the indirect thing */
  t5 = (u32)t2;
  goto g7099;

g7102:
  if (_trace) printf("g7102:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g7105:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

g7091:
  if (_trace) printf("g7091:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  t6 = *(s32 *)t8;
  /* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g7090;

g7093:
  if (_trace) printf("g7093:\n");
  if ((t10 & 1) == 0)
    goto g7092;
  /* Do the indirect thing */
  t1 = (u32)t6;
  goto g7089;

g7092:
  if (_trace) printf("g7092:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t7 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g7095:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

/* end HANDLEFRAMECLEANUP */
/* start StackCacheUnderflowCheck */


stackcacheunderflowcheck:
  if (_trace) printf("stackcacheunderflowcheck:\n");
  t1 = *(u64 *)&(processor->stackcachedata);
  /* Preserve through instruction's original SP */
  t4 = *(u64 *)&(processor->restartsp);
  /* Number of words*8 to fill iff positive */
  t3 = t1 - iFP;
  if ((s64)t3 <= 0)
    goto interpretinstructionforbranch;
  /* Convert to a word count */
  t3 = (s64)t3 >> 3;
  /* Account for the inclusive limit */
  t4 = t4 + 8;
  /* in case only low three bits nonzero */
  if ((s64)t3 <= 0)
    goto interpretinstructionforbranch;
  r0 = (u64)&&return0039;
  goto stackcacheunderflow;
return0039:
  goto interpretinstructionforbranch;

/* end StackCacheUnderflowCheck */
/* start StackCacheUnderflow */


stackcacheunderflow:
  if (_trace) printf("stackcacheunderflow:\n");
  /* Compute target address for shift */
  t2 = (t3 * 8) + t1;
  /* Compute number of elements to preserve */
  t5 = t4 - t1;
  /* Convert to word count */
  t5 = (s64)t5 >> 3;
  /* Shove everything up */
  /* Adjust to end of source block */
  t1 = (t5 * 8) + t1;
  /* Adjust to end of target block */
  t2 = (t5 * 8) + t2;
  goto g7123;

g7124:
  if (_trace) printf("g7124:\n");
  /* advance from position */
  t1 = t1 - 8;
  t5 = t5 - 1;
  /* Get a word from source */
  t7 = *(u64 *)t1;
  /* advance to position */
  t2 = t2 - 8;
  /* Put word in destination */
  *(u64 *)t2 = t7;

g7123:
  if ((s64)t5 > 0)
    goto g7124;
  /* Adjust stack cache relative registers */
  iFP = (t3 * 8) + iFP;
  t4 = *(u64 *)&(processor->restartsp);
  iSP = (t3 * 8) + iSP;
  iLP = (t3 * 8) + iLP;
  t4 = (t3 * 8) + t4;
  /* Fill freshly opened slots of stack cache from memory */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t2 = *(u64 *)&(processor->stackcachedata);
  *(u64 *)&processor->restartsp = t4;
  /* Compute new base address of stack cache */
  t1 = t1 - t3;
  /* Top of cache */
  t4 = *(u64 *)&(processor->stackcachetopvma);
  *(u64 *)&processor->stackcachebasevma = t1;
  /* Adjust top of cache */
  t4 = t4 - t3;
  *(u64 *)&processor->stackcachetopvma = t4;
  t7 = t1 + ivory;
  t5 = (t7 * 4);
  t4 = LDQ_U(t7);
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t7&7)*8));
  goto g7125;

g7126:
  if (_trace) printf("g7126:\n");
  t7 = t1 + ivory;
  t5 = (t7 * 4);
  t4 = LDQ_U(t7);
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t7&7)*8));
  t3 = t3 - 1;
  /* advance vma position */
  t1 = t1 + 1;
  *(u32 *)t2 = t5;
  /* write the stack cache */
  *(u32 *)(t2 + 4) = t4;
  /* advance sca position */
  t2 = t2 + 8;

g7125:
  if ((s64)t3 > 0)
    goto g7126;
#ifdef TRACING
  /* Trace instructions if requested. */
  t4 = *(u64 *)&(processor->trace_hook);
  /* J. if not tracing. */
  if (t4 == 0)
    goto g7131;
  /* Record an instruction trace entry */
  t5 = *(s32 *)&t4->tracedata_recording_p;
  t1 = *(u64 *)&(t4->tracedata_start_pc);
  /* Jump if recording is on */
  if (t5 != 0)
    goto g7127;
  /* Turn recording on if at the start PC */
  t1 = (t1 == iPC) ? 1 : 0;
  *(u32 *)&t4->tracedata_recording_p = t1;
  /* Jump if not at the start PC */
  if (t1 == 0)
    goto g7131;

g7127:
  if (_trace) printf("g7127:\n");
  /* Get address of next trace record  */
  t5 = *(u64 *)&(t4->tracedata_current_entry);
  t1 = *(u64 *)&(processor->instruction_count);
  /* Save current PC */
  *(u64 *)&t5->tracerecord_epc = iPC;
  /* Save instruction count */
  *(u64 *)&t5->tracerecord_counter = t1;
  t1 = *(u64 *)iSP;
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t3 = iSP - t3;
  /* convert byte address to word address */
  t3 = t3 >> 3;
  /* reconstruct VMA */
  t2 = t3 + t2;
  /* Save current value of TOS */
  *(u64 *)&t5->tracerecord_tos = t1;
  /* Save current SP */
  *(u64 *)&t5->tracerecord_sp = t2;
  t1 = *(s32 *)&((CACHELINEP)iCP)->operand;
  t2 = *(u64 *)&(((CACHELINEP)iCP)->code);
  /* Save current instruction's operand */
  *(u32 *)&t5->tracerecord_operand = t1;
  /* Save pointer to current instruction code */
  *(u64 *)&t5->tracerecord_instruction = t2;
  t2 = *(u64 *)&(processor->control);
  t3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  /* We don't yet record catch blocks */
  *(u32 *)&t5->tracerecord_catch_block_p = zero;
  /* Save control register */
  *(u64 *)&t5->tracerecord_catch_block_0 = t2;
  t1 = *(u64 *)&(processor->tvi);
  /* Save full word instruction operand */
  *(u64 *)&t5->tracerecord_instruction_data = t3;
  /* Save trap indiciator */
  *(u32 *)&t5->tracerecord_trap_p = t1;
  /* Jump if didn't trap */
  if (t1 == 0)
    goto g7128;
  t1 = *(u64 *)(iFP + 16);
  /* Zero flag to avoid false trap entries */
  *(u64 *)&processor->tvi = zero;
  t2 = *(u64 *)(iFP + 24);
  /* Save trap vector index */
  *(u64 *)&t5->tracerecord_trap_data_0 = t1;
  t3 = *(u64 *)(iFP + 32);
  /* Save fault PC */
  *(u64 *)&t5->tracerecord_trap_data_1 = t2;
  t6 = *(u64 *)(iFP + 40);
  /* Save two additional arguments */
  *(u64 *)&t5->tracerecord_trap_data_2 = t3;
  *(u64 *)&t5->tracerecord_trap_data_3 = t6;

g7128:
  if (_trace) printf("g7128:\n");
  /* Bump to next trace record */
  t5 = t5 + tracerecordsize;
  /* Get pointer to start of trace records */
  t1 = *(u64 *)&(t4->tracedata_records_start);
  /* Set record pointer to keep printer happy */
  *(u64 *)&t4->tracedata_current_entry = t5;
  /* Get pointer to end of trace record */
  t2 = *(u64 *)&(t4->tracedata_records_end);
  /* Function to print trace if non-zero */
  t3 = *(u64 *)&(t4->tracedata_printer);
  /* Non-zero iff we're about to wrap the circular buffer */
  t2 = ((s64)t2 <= (s64)t5) ? 1 : 0;
  /* Update next record pointer iff we wrapped */
  if (t2)
    t5 = t1;
  /* Don't print if we didn't wrap */
  if (t2 == 0)
    t3 = zero;
  /* Jump if we don't need to print */
  if (t3 == 0)
    goto g7129;
  *(u64 *)&processor->cp = iCP;
  *(u64 *)&processor->epc = iPC;
  *(u64 *)&processor->sp = iSP;
  *(u64 *)&processor->fp = iFP;
  *(u64 *)&processor->lp = iLP;
  *(u64 *)&processor->asrf2 = arg1;
  *(u64 *)&processor->asrf3 = arg2;
  *(u64 *)&processor->asrf4 = arg3;
  *(u64 *)&processor->asrf5 = arg4;
  *(u64 *)&processor->asrf6 = arg5;
  *(u64 *)&processor->asrf7 = arg6;
  *(u64 *)&processor->asrf8 = t4;
  *(u64 *)&processor->asrf9 = t5;
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  pv = t3;
    r0 = (*( u64 (*)(u64, u64) )t3)(arg1, arg2); /* jsr */
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  arg1 = *(u64 *)&(processor->asrf2);
  arg2 = *(u64 *)&(processor->asrf3);
  arg3 = *(u64 *)&(processor->asrf4);
  arg4 = *(u64 *)&(processor->asrf5);
  arg5 = *(u64 *)&(processor->asrf6);
  arg6 = *(u64 *)&(processor->asrf7);
  t4 = *(u64 *)&(processor->asrf8);
  t5 = *(u64 *)&(processor->asrf9);
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* Claim we didn't wrap */
  t2 = zero;

g7129:
  if (_trace) printf("g7129:\n");
  /* Save next record pointer */
  *(u64 *)&t4->tracedata_current_entry = t5;
  /* Jump if we didn't wrap */
  if (t2 == 0)
    goto g7130;
  /* Set flag indicating that we wrapped */
  *(u32 *)&t4->tracedata_wrap_p = t2;

g7130:
  if (_trace) printf("g7130:\n");
  t5 = *(u64 *)&(t4->tracedata_stop_pc);
  /* Non-zero if at PC where we should stop tracing */
  t5 = (t5 == iPC) ? 1 : 0;
  /* Non-zero if not at the PC */
  t5 = (t5 == 0) ? 1 : 0;
  /* Update recording flag */
  *(u32 *)&t4->tracedata_recording_p = t5;

g7131:
  if (_trace) printf("g7131:\n");
#endif
  goto *((void* )r0); /* ret */

/* end StackCacheUnderflow */
/* start StackCacheOverflowHandler */


stackcacheoverflowhandler:
  if (_trace) printf("stackcacheoverflowhandler:\n");
  /* Stack cache overflow detected */
  t1 = zero + 256;
  /* Account for what we're about to push */
  t1 = t1 + arg2;
  /* SCA of desired end of cache */
  t1 = (t1 * 8) + iSP;
  iSP = *(u64 *)&(processor->restartsp);
  /* Alpha base of stack cache */
  t4 = *(u64 *)&(processor->stackcachedata);
  /* New limit*8 */
  t4 = t1 - t4;
  t4 = t4 >> 3;
  /* Update stack cache limit */
  *(u32 *)&processor->scovlimit = t4;
  /* Check that the page underlying the end of the stack cache is accessible */
  /* Convert stack cache address to VMA */
  t4 = *(u64 *)&(processor->stackcachedata);
  t3 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t4 = t1 - t4;
  /* convert byte address to word address */
  t4 = t4 >> 3;
  /* reconstruct VMA */
  t3 = t4 + t3;
  /* Per-page attributes table */
  t5 = *(u64 *)&(processor->vmattributetable);
  /* Index into the attributes table */
  t4 = t3 >> (MemoryPage_AddressShift & 63);
  /* Address of the page's attributes */
  t5 = t4 + t5;
  /* Get the quadword with the page's attributes */
  t4 = LDQ_U(t5);
  /* Stash the VMA */
  *(u64 *)&processor->vma = t3;
  /* Extract the page's attributes */
  t4 = (u8)(t4 >> ((t5&7)*8));
  /* Non-existent page */
  if (t4 == 0)
    goto pagenotresident;
  t5 = t4 & VMAttribute_AccessFault;
  /* Access fault */
  if (t5 != 0)
    goto pagefaultrequesthandler;
  t5 = t4 & VMAttribute_WriteFault;
  /* Write fault */
  if (t5 != 0)
    goto pagewritefault;
  /* Check if we must dump the cache */
  /* New stack cache limit (words) */
  t4 = *(s32 *)&processor->scovlimit;
  /* Absolute size of the cache (words) */
  t5 = *(u64 *)&(processor->stackcachesize);
  t5 = ((s64)t4 <= (s64)t5) ? 1 : 0;
  /* We're done if new limit is less than absolute limit */
  if (t5 != 0)
    goto INTERPRETINSTRUCTION;
  /* Dump the stack cache to make room */
  t1 = zero + 896;
  /* Stack cache base VMA */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* Alpha base of stack cache */
  t3 = *(u64 *)&(processor->stackcachedata);
  /* Will be destructively modified */
  *(u32 *)&processor->scovdumpcount = t1;
  /* Starting address of tags */
  t5 = t2 + ivory;
  /* Starting address of data */
  t2 = (t5 * 4);
  /* Dump the data */
  goto g7132;

g7133:
  if (_trace) printf("g7133:\n");
  /* Get data word */
  t4 = *(s32 *)t3;
  t1 = t1 - 1;
  /* Advance SCA position */
  t3 = t3 + 8;
  /* Save data word */
  *(u32 *)t2 = t4;
  /* Advance VMA position */
  t2 = t2 + 4;

g7132:
  if ((s64)t1 > 0)
    goto g7133;
  /* Dump the tags */
  /* Restore the count */
  t1 = *(s32 *)&processor->scovdumpcount;
  /* Restore tag VMA */
  t2 = t5;
  t4 = t1 << 3;
  /* Restore orginal SCA */
  t3 = t3 - t4;
  goto g7134;

g7135:
  if (_trace) printf("g7135:\n");
  t1 = t1 - 1;
  /* Get tag word */
  t4 = *(s32 *)(t3 + 4);
  /* Advance SCA position */
  t3 = t3 + 8;
  /* Get packed tags word */
  t5 = LDQ_U(t2);
  /* Position the new tag */
  t4 = (t4 & 0xff) << ((t2&7)*8);
  /* Remove old tag */
  t5 = t5 & ~(0xffL << (t2&7)*8);
  /* Put in new byte */
  t5 = t4 | t5;
  /* Save packed tags word */
  STQ_U(t2, t5);
  /* Advance VMA position */
  t2 = t2 + 1;

g7134:
  if ((s64)t1 > 0)
    goto g7135;
  t1 = zero + 896;
  /* Stack cache base VMA */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* Top of cache */
  t4 = *(u64 *)&(processor->stackcachetopvma);
  /* Cache limit in words */
  t5 = *(s32 *)&processor->scovlimit;
  /* Adjust cache base VMA */
  t2 = t2 + t1;
  /* Adjust top of cache */
  t4 = t4 + t1;
  /* Adjust limit */
  t5 = t5 - t1;
  /* Save update */
  *(u64 *)&processor->stackcachebasevma = t2;
  *(u64 *)&processor->stackcachetopvma = t4;
  *(u32 *)&processor->scovlimit = t5;
  /* Move the cache down */
  /* Alpha base of stack cache */
  t3 = *(u64 *)&(processor->stackcachedata);
  /* SCA of first word of new base */
  t2 = (t1 * 8) + t3;
  goto g7136;

g7137:
  if (_trace) printf("g7137:\n");
  t1 = t1 - 1;
  /* Get a word from source */
  t5 = *(u64 *)t2;
  /* advance from position */
  t2 = t2 + 8;
  /* Put word in destination */
  *(u64 *)t3 = t5;
  /* advance to position */
  t3 = t3 + 8;

g7136:
  if ((s64)t1 > 0)
    goto g7137;
  /* Adjust stack cache relative registers */
  t1 = zero + 896;
  /* Convert to SCA adjustment */
  t1 = t1 << 3;
  iSP = iSP - t1;
  iFP = iFP - t1;
  iLP = iLP - t1;
  *(u64 *)&processor->restartsp = iSP;
  goto INTERPRETINSTRUCTION;

/* end StackCacheOverflowHandler */
/* start DoReturnKludge */

  /* Halfword operand from stack instruction - DoReturnKludge */
  /* arg2 has the preloaded 8 bit operand. */

doreturnkludge:
  if (_trace) printf("doreturnkludge:\n");
#ifdef TRACING
#endif

DoReturnKludgeSP:
  if (_trace) printf("DoReturnKludgeSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoreturnkludge;
#endif

DoReturnKludgeLP:
  if (_trace) printf("DoReturnKludgeLP:\n");
#ifdef TRACING
  goto begindoreturnkludge;
#endif

DoReturnKludgeFP:
  if (_trace) printf("DoReturnKludgeFP:\n");

begindoreturnkludge:
  if (_trace) printf("begindoreturnkludge:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t1 = *(s32 *)(arg1 + 4);
  arg2 = *(s32 *)arg1;
  t2 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t2 = t2 & 63;
  if (t2 != 0)
    goto returnkludgeio;
  arg2 = (u32)arg2;
#ifdef TRACING
  goto DoReturnKludgeIM;
#endif

DoReturnKludgeIM:
  if (_trace) printf("DoReturnKludgeIM:\n");
  arg6 = *(u64 *)&(processor->stackcachedata);
  t1 = (arg2 * 8) - 8;
  t2 = *(s32 *)&processor->control;
  /* t1 is the values block */
  t1 = iSP - t1;
  /* Restore machine state from frame header. */
  t5 = *(s32 *)iFP;
  t3 = (1792) << 16;
  t7 = *(s32 *)&processor->continuation;
  /* Mask */
  t3 = t2 & t3;
  t4 = *(s32 *)(iFP + 4);
  t9 = iCP;
  /* Need to cleanup frame first */
  if (t3 != 0)
    goto returnkludgecleanup;
  t5 = (u32)t5;
  t6 = *((s32 *)(&processor->continuation)+1);
  t7 = (u32)t7;
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  /* check for end of run */
  t8 = (s32)t4 - (s32)Type_NIL;
  if (t8 == 0)
    goto g7138;
#endif
  /* Get saved control register */
  t8 = *(s32 *)(iFP + 8);
  /* TagType. */
  t4 = t4 & 63;
  /* Restore the PC. */
  /* Assume even PC */
  iPC = t7 << 1;
  t3 = t6 & 1;
  t9 = *(u64 *)&(processor->continuationcp);
  iPC = iPC + t3;

g7140:
  if (_trace) printf("g7140:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t4;
  /* Get the caller frame size into place */
  t3 = t2 >> 9;
  *(u32 *)&processor->continuation = t5;
  /* Restore the stack pointer. */
  iSP = iFP - 8;
  *(u64 *)&processor->continuationcp = zero;
  /* Mask just the caller frame size. */
  t3 = t3 & 255;
  /* *8 */
  t3 = (t3 * 8) + 0;
  t4 = (2048) << 16;
  t4 = t4 & t2;
  /* Get the preempt-pending bit */
  t5 = *(s32 *)&processor->interruptreg;
  /* Sticky trace pending bit. */
  t8 = t4 | t8;
  /* Get the trap/suspend bits */
  t6 = *(u64 *)&(processor->please_stop);
  /* Restore the frame pointer. */
  iFP = iFP - t3;
  /* Restore the control register */
  *(u32 *)&processor->control = t8;
  /* extract the argument size */
  t3 = t8 & 255;
  t5 = t5 & 1;
  t5 = t6 | t5;
  *(u64 *)&processor->stop_interpreter = t5;
  /* Restore the local pointer. */
  iLP = (t3 * 8) + iFP;
  /* ARG6 = stack-cache underflow */
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;
  if (arg2 == 0)
    goto rkloopdone;

rklooptop:
  if (_trace) printf("rklooptop:\n");
  /* Read a 40 bit word from the values block */
  t4 = *(u64 *)t1;
  arg2 = arg2 - 1;
  /* Push value onto stack cdr codes and all */
  *(u64 *)(iSP + 8) = t4;
  t1 = t1 + 8;
  iSP = iSP + 8;
  if ((s64)arg2 > 0)
    goto rklooptop;

rkloopdone:
  if (_trace) printf("rkloopdone:\n");
  if (arg6 != 0)
    goto returnkludgeunderflow;
  /* No prediction, validate cache */
  if (t9 == 0)
    goto interpretinstructionforbranch;
  iCP = t9;
  goto INTERPRETINSTRUCTION;

returnkludgeio:
  if (_trace) printf("returnkludgeio:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

returnkludgecleanup:
  if (_trace) printf("returnkludgecleanup:\n");
  goto handleframecleanup;

returnkludgeunderflow:
  if (_trace) printf("returnkludgeunderflow:\n");
  goto stackcacheunderflowcheck;

/* end DoReturnKludge */
  /* End of Halfword operand from stack instruction - DoReturnKludge */
/* start DoTakeValues */

  /* Halfword operand from stack instruction - DoTakeValues */
  /* arg2 has the preloaded 8 bit operand. */

dotakevalues:
  if (_trace) printf("dotakevalues:\n");
#ifdef TRACING
#endif

DoTakeValuesIM:
  if (_trace) printf("DoTakeValuesIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindotakevalues;
#ifdef TRACING
#endif

DoTakeValuesSP:
  if (_trace) printf("DoTakeValuesSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdotakevalues;
#endif

DoTakeValuesLP:
  if (_trace) printf("DoTakeValuesLP:\n");
#ifdef TRACING
  goto headdotakevalues;
#endif

DoTakeValuesFP:
  if (_trace) printf("DoTakeValuesFP:\n");

headdotakevalues:
  if (_trace) printf("headdotakevalues:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindotakevalues:
  if (_trace) printf("begindotakevalues:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg6 = *(u64 *)&(processor->niladdress);
  /* Number of values expected */
  arg1 = (u32)arg1;
  /* Number of values provided */
  arg4 = *(s32 *)iSP;
  /* Number of values provided */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 - arg4;
  /* J. if too many args supplied */
  if ((s64)arg2 < 0)
    goto takevalueslose;
  /* J. if too few values supplied */
  if ((s64)arg2 > 0)
    goto takevaluespad;
  goto NEXTINSTRUCTION;

takevalueslose:
  if (_trace) printf("takevalueslose:\n");
  /* Remove the unwanted values */
  iSP = (arg2 * 8) + iSP;
  goto NEXTINSTRUCTION;

takevaluespad:
  if (_trace) printf("takevaluespad:\n");
  /* Current stack cache limit (words) */
  t4 = *(s32 *)&processor->scovlimit;
  t1 = zero + 128;
  /* Alpha base of stack cache */
  t2 = *(u64 *)&(processor->stackcachedata);
  /* Account for what we're about to push */
  t1 = t1 + arg2;
  /* SCA of desired end of cache */
  t1 = (t1 * 8) + iSP;
  /* SCA of current end of cache */
  t2 = (t4 * 8) + t2;
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t4 == 0)
    goto stackcacheoverflowhandler;

takevaluespadloop:
  if (_trace) printf("takevaluespadloop:\n");
  /* Push NIL */
  *(u64 *)(iSP + 8) = arg6;
  iSP = iSP + 8;
  arg2 = arg2 - 1;
  if ((s64)arg2 > 0)
    goto takevaluespadloop;
  goto NEXTINSTRUCTION;

/* end DoTakeValues */
  /* End of Halfword operand from stack instruction - DoTakeValues */
  /* Catch Instructions */
/* start DoCatchOpen */

  /* Halfword 10 bit immediate instruction - DoCatchOpen */

docatchopen:
  if (_trace) printf("docatchopen:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCatchOpenIM:
  if (_trace) printf("DoCatchOpenIM:\n");

DoCatchOpenSP:
  if (_trace) printf("DoCatchOpenSP:\n");

DoCatchOpenLP:
  if (_trace) printf("DoCatchOpenLP:\n");

DoCatchOpenFP:
  if (_trace) printf("DoCatchOpenFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* t10=1 if unwind-protect, t10=0 if catch */
  t10 = arg1 & 1;
  /* tag */
  t3 = *((s32 *)(&processor->catchblock)+1);
  t10 = t10 << 38;
  /* data */
  t4 = *(s32 *)&processor->catchblock;
  t2 = *(u64 *)&(processor->bindingstackpointer);
  /* Convert stack cache address to VMA */
  t1 = *(u64 *)&(processor->stackcachedata);
  t9 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t1 = iSP - t1;
  /* convert byte address to word address */
  t1 = t1 >> 3;
  /* reconstruct VMA */
  t9 = t1 + t9;
  t1 = t10 | t2;
  *(u64 *)(iSP + 8) = t1;
  iSP = iSP + 8;
  t11 = *(s32 *)&processor->control;
  /* Get old cleanup catch bit */
  t2 = t11 >> 20;
  t2 = t2 & 64;
  /* Get old extra arg bit */
  t1 = t11 >> 1;
  t1 = t1 & 128;
  t1 = t1 | t2;
  /* TagType. */
  t2 = t3 & 63;
  /* T1 now has new tag */
  t1 = t1 | t2;
  *(u32 *)(iSP + 8) = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  if (t10 != 0)
    goto catchopen2;
  t2 = *(s32 *)&processor->continuation;
  t1 = *((s32 *)(&processor->continuation)+1);
  t2 = (u32)t2;
  /* TagType. */
  t1 = t1 & 63;
  /* T3 has the disposition bits in place */
  t3 = arg1 & 192;
  t1 = t1 | t3;
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;

catchopen2:
  if (_trace) printf("catchopen2:\n");
  t1 = Type_Locative;
  /* tag */
  *((u32 *)(&processor->catchblock)+1) = t1;
  /* data */
  *(u32 *)&processor->catchblock = t9;
  t1 = (1024) << 16;
  /* set it */
  t1 = t1 | t11;
  *(u32 *)&processor->control = t1;
  goto NEXTINSTRUCTION;

/* end DoCatchOpen */
  /* End of Halfword operand from stack instruction - DoCatchOpen */
/* start DoCatchClose */

  /* Halfword operand from stack instruction - DoCatchClose */
  /* arg2 has the preloaded 8 bit operand. */

docatchclose:
  if (_trace) printf("docatchclose:\n");
#ifdef TRACING
#endif

DoCatchCloseSP:
  if (_trace) printf("DoCatchCloseSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindocatchclose;
#endif

DoCatchCloseLP:
  if (_trace) printf("DoCatchCloseLP:\n");
#ifdef TRACING
  goto begindocatchclose;
#endif

DoCatchCloseFP:
  if (_trace) printf("DoCatchCloseFP:\n");

begindocatchclose:
  if (_trace) printf("begindocatchclose:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* data */
  t1 = *(s32 *)&processor->catchblock;
  t1 = (u32)t1;
  /* Convert VMA to stack cache address */
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t10 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t3 = t1 - t3;
  /* reconstruct SCA */
  t10 = (t3 * 8) + t10;
  /* bstag bsdata */
  arg4 = *(s32 *)(t10 + 8);
  arg3 = *(s32 *)(t10 + 12);
  arg4 = (u32)arg4;
  t4 = *(u64 *)&(processor->bindingstackpointer);
  /* prtag prdata */
  arg6 = *(s32 *)(t10 + 16);
  arg5 = *(s32 *)(t10 + 20);
  arg6 = (u32)arg6;
  t3 = t4 >> 32;
  t5 = (s32)arg4 - (s32)t4;
  if (t5 == 0)
    goto catchcloseld;
  t1 = t3 - Type_Locative;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto catchclosedbt;

catchcloselt:
  if (_trace) printf("catchcloselt:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);
  t4 = *(s32 *)&processor->control;
  /* vma only */
  t1 = (u32)t1;
  t2 = (512) << 16;
  t5 = t1 - 1;
  t3 = t4 & t2;
  /* Turn off the bit */
  t4 = t4 & ~t2;
  if (t3 != 0)
    goto g7142;
  /* Get the SP, ->op2 */
  t4 = *(u64 *)&(processor->restartsp);
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g7142:
  if (_trace) printf("g7142:\n");
  /* Memory Read Internal */

g7143:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  arg1 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t6 = (arg1 * 4);
  t7 = LDQ_U(arg1);
  /* Stack cache offset */
  t8 = t1 - t8;
  arg2 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((arg1&7)*8));
  if (t9 != 0)
    goto g7145;

g7144:
  arg1 = zero + 224;
  arg2 = arg2 >> (t7 & 63);
  arg1 = arg1 >> (t7 & 63);
  if (arg2 & 1)
    goto g7147;

g7152:
  /* Memory Read Internal */

g7153:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  arg1 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t2 = (arg1 * 4);
  t3 = LDQ_U(arg1);
  /* Stack cache offset */
  t8 = t5 - t8;
  arg2 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  t2 = *(s32 *)t2;
  t3 = (u8)(t3 >> ((arg1&7)*8));
  if (t9 != 0)
    goto g7155;

g7154:
  arg1 = zero + 224;
  arg2 = arg2 >> (t3 & 63);
  arg1 = arg1 >> (t3 & 63);
  t2 = (u32)t2;
  if (arg2 & 1)
    goto g7157;

g7162:
  /* Memory Read Internal */

g7163:
  /* Base of stack cache */
  arg1 = *(u64 *)&(processor->stackcachebasevma);
  t11 = t2 + ivory;
  arg2 = *(s32 *)&processor->scovlimit;
  t9 = (t11 * 4);
  t8 = LDQ_U(t11);
  /* Stack cache offset */
  arg1 = t2 - arg1;
  /* In range? */
  arg2 = ((u64)arg1 < (u64)arg2) ? 1 : 0;
  t9 = *(s32 *)t9;
  t8 = (u8)(t8 >> ((t11&7)*8));
  if (arg2 != 0)
    goto g7165;

g7164:
  arg1 = *(u64 *)&(processor->bindwrite_mask);
  t11 = zero + 224;
  arg1 = arg1 >> (t8 & 63);
  t11 = t11 >> (t8 & 63);
  if (arg1 & 1)
    goto g7167;

g7172:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  arg1 = t2 + ivory;
  t9 = (arg1 * 4);
  t11 = LDQ_U(arg1);
  arg2 = (t8 & 0xff) << ((arg1&7)*8);
  t11 = t11 & ~(0xffL << (arg1&7)*8);

g7175:
  if (_trace) printf("g7175:\n");
  t11 = t11 | arg2;
  arg2 = *(u64 *)&(processor->stackcachebasevma);
  STQ_U(arg1, t11);
  arg1 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  arg2 = t2 - arg2;
  /* In range? */
  arg1 = ((u64)arg2 < (u64)arg1) ? 1 : 0;
  *(u32 *)t9 = t6;
  /* J. if in cache */
  if (arg1 != 0)
    goto g7174;

g7173:
  /* Get the old cleanup-bindings bit */
  t3 = t3 & 64;
  t3 = t3 << 19;
  t1 = t1 - 2;
  /* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  t5 = (s32)arg4 - (s32)t1;
  if (t5 != 0)
    goto catchcloselt;
  t3 = *(s32 *)&processor->interruptreg;
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0)
    goto g7176;
  *(u64 *)&processor->stop_interpreter = t3;

g7176:
  if (_trace) printf("g7176:\n");

catchcloseld:
  if (_trace) printf("catchcloseld:\n");
  /* TagType. */
  t1 = arg5 & 63;
  /* tag */
  *((u32 *)(&processor->catchblock)+1) = t1;
  /* extra argument bit */
  t2 = arg5 & 128;
  /* mask for two bits */
  t6 = *(u64 *)&(processor->extraandcatch);
  /* position in place for control register. */
  t2 = t2 << 1;
  /* data */
  *(u32 *)&processor->catchblock = arg6;
  /* cleanup catch bit */
  t3 = arg5 & 64;
  /* position in place for cr */
  t3 = t3 << 20;
  t4 = *(s32 *)&processor->control;
  /* coalesce the two bits */
  t5 = t2 | t3;
  /* Turn off extra-arg and cleanup-catch */
  t4 = t4 & ~t6;
  /* Maybe turn them back on */
  t4 = t4 | t5;
  *(u32 *)&processor->control = t4;
  /* uwp bit */
  t6 = arg3 & 64;
  if (t6 == 0)
    goto NEXTINSTRUCTION;
  /* Handle unwind-protect cleanup here */
  /* pctag pcdata */
  arg2 = *(s32 *)t10;
  arg1 = *(s32 *)(t10 + 4);
  arg2 = (u32)arg2;
  /* Cleanup in progress bit into cdr code pos */
  t8 = t4 >> 17;
  /* Next PC */
  t7 = iPC + 1;
  /* Convert PC to a real continuation. */
  t8 = t7 & 1;
  /* convert PC to a real word address. */
  t10 = t7 >> 1;
  t8 = t8 + Type_EvenPC;
  /* TagType. */
  t7 = t8 & 63;
  t8 = t8 & 64;
  t9 = (128) << 16;
  t8 = t8 | 128;
  t7 = t7 | t8;
  *(u32 *)(iSP + 8) = t10;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  /* set cr.cleanup-in-progress */
  t4 = t4 | t9;
  *(u32 *)&processor->control = t4;
  /* Convert real continuation to PC. */
  iPC = arg1 & 1;
  iPC = arg2 + iPC;
  iPC = arg2 + iPC;
  goto interpretinstructionforjump;

catchclosedbt:
  if (_trace) printf("catchclosedbt:\n");
  goto dbunwindcatchtrap;

g7174:
  if (_trace) printf("g7174:\n");
  arg1 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  arg1 = (arg2 * 8) + arg1;
  /* Store in stack */
  *(u32 *)arg1 = t6;
  /* write the stack cache */
  *(u32 *)(arg1 + 4) = t8;
  goto g7173;

g7165:
  if (_trace) printf("g7165:\n");
  arg2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  arg1 = (arg1 * 8) + arg2;
  t9 = *(s32 *)arg1;
  /* Read from stack cache */
  t8 = *(s32 *)(arg1 + 4);
  goto g7164;

g7167:
  if (_trace) printf("g7167:\n");
  if ((t11 & 1) == 0)
    goto g7166;
  /* Do the indirect thing */
  t2 = (u32)t9;
  goto g7163;

g7166:
  if (_trace) printf("g7166:\n");
  /* Load the memory action table for cycle */
  arg1 = *(u64 *)&(processor->bindwrite);
  /* TagType. */
  /* Discard the CDR code */
  t11 = t8 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t11 = (t11 * 4) + arg1;
  /* Get the memory action */
  arg1 = *(s32 *)t11;

g7169:
  /* Perform memory action */
  arg1 = arg1;
  arg2 = 3;
  goto performmemoryaction;

g7155:
  if (_trace) printf("g7155:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  t2 = *(s32 *)t8;
  /* Read from stack cache */
  t3 = *(s32 *)(t8 + 4);
  goto g7154;

g7157:
  if (_trace) printf("g7157:\n");
  if ((arg1 & 1) == 0)
    goto g7156;
  /* Do the indirect thing */
  t5 = (u32)t2;
  goto g7153;

g7156:
  if (_trace) printf("g7156:\n");
  /* Load the memory action table for cycle */
  arg2 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  arg1 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  arg1 = (arg1 * 4) + arg2;
  /* Get the memory action */
  arg2 = *(s32 *)arg1;

g7159:
  /* Perform memory action */
  arg1 = arg2;
  arg2 = 2;
  goto performmemoryaction;

g7145:
  if (_trace) printf("g7145:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  t6 = *(s32 *)t8;
  /* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g7144;

g7147:
  if (_trace) printf("g7147:\n");
  if ((arg1 & 1) == 0)
    goto g7146;
  /* Do the indirect thing */
  t1 = (u32)t6;
  goto g7143;

g7146:
  if (_trace) printf("g7146:\n");
  /* Load the memory action table for cycle */
  arg2 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  arg1 = t7 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  arg1 = (arg1 * 4) + arg2;
  /* Get the memory action */
  arg2 = *(s32 *)arg1;

g7149:
  /* Perform memory action */
  arg1 = arg2;
  arg2 = 2;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoCatchCloseIM:
  goto doistageerror;

/* end DoCatchClose */
  /* End of Halfword operand from stack instruction - DoCatchClose */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfcal.as */
